import{r as M,u as W,M as nt,s as Qn,j as N,F as Q,a as j,C as ti,S as qe,U as ei,b as en,B as An,R as et,c as Sn,V as k,d as zt,P as Pn,L as ct,T as Ft,e as ni,f as mt,g as rt,D as ii,h as nn,i as _n,k as si,l as It,m as ae,n as Tn,E as le,o as $t,p as ri,q as oi,t as ci,v as sn,w as ai,x as pt,G as fe,y as Cn,z as Bn,A as li,H as Mt,I as ui,J as fi,O as pi}from"./index-d2b67d33.js";import{Vector3 as di,Vector2 as mi,UniformsUtils as Mn,UniformsLib as rn,ShaderMaterial as hi}from"//cdn.skypack.dev/three@0.130.1/build/three.module.js";import"//cdn.skypack.dev/three@0.130.1/examples/jsm/lines/LineSegmentsGeometry.js";function yi(){const n=M.useRef(),e=W(s=>s.wiringStep);let{currentStepObject:t,setCurrentSVG:i}=M.useContext(nt);return M.useEffect(()=>{e&&document.getElementById("myEmbed").addEventListener("load",function(){i(Qn(document.getElementById("myEmbed")))})},[e]),N(Q,{children:e?N("div",{id:"svgContainer",style:{position:"absolute",width:"100%",height:"100%",bottom:"0px",left:"0px",padding:"10px"},children:N("embed",{style:{width:"100%",height:"100%",backgroundColor:"#e9e9e9"},ref:n,type:"image/svg+xml",src:`./${t.name}.svg`,id:"myEmbed"})}):null})}function gi(){let{setStepPosition:n,stepCount:e,stepList:t}=M.useContext(nt);const i=()=>{e++,n(e)},s=()=>{e--,n(e)};return j(Q,{children:[e>=1?N("button",{onClick:s,className:"btn",id:"nextStep",children:" ❮ Previous Step  "}):null,t&&e+1<=t.length-1?N("button",{onClick:i,className:"btn",id:"nextStep",children:"Next Step ❯ "}):null]})}function xi(){const{setModelInOut:n,selectedParts:e}=M.useContext(nt),[t,i]=M.useState(!1),s=W(r=>r.wiringStep);return N(Q,{children:s?null:N("button",{onClick:()=>{t==!1?(document.getElementById("partsOut").innerHTML="Assemble",i(!0),n(t)):t==!0&&(document.getElementById("partsOut").innerHTML="Explode",i(!1),n(t))},className:"btn",id:"partsOut",children:"Explode"})})}class vi{constructor(e,t={}){this.enabled=!0;const i=t.defaultThickness!==void 0?t.defaultThickness:.003,s=new ti().fromArray(t.defaultColor!==void 0?t.defaultColor:[0,0,0]),a=t.defaultAlpha!==void 0?t.defaultAlpha:1,r=t.defaultKeepAlive!==void 0?t.defaultKeepAlive:!1,o={},c=60,f={},l={},p={outlineThickness:{value:i},outlineColor:{value:s},outlineAlpha:{value:a}},u=["#include <common>","#include <uv_pars_vertex>","#include <displacementmap_pars_vertex>","#include <fog_pars_vertex>","#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","uniform float outlineThickness;","vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {","	float thickness = outlineThickness;","	const float ratio = 1.0;","	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );","	vec4 norm = normalize( pos - pos2 );","	return pos + norm * thickness * pos.w * ratio;","}","void main() {","	#include <uv_vertex>","	#include <beginnormal_vertex>","	#include <morphnormal_vertex>","	#include <skinbase_vertex>","	#include <skinnormal_vertex>","	#include <begin_vertex>","	#include <morphtarget_vertex>","	#include <skinning_vertex>","	#include <displacementmap_vertex>","	#include <project_vertex>","	vec3 outlineNormal = - objectNormal;","	gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );","	#include <logdepthbuf_vertex>","	#include <clipping_planes_vertex>","	#include <fog_vertex>","}"].join(`
`),m=["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","#include <clipping_planes_pars_fragment>","uniform vec3 outlineColor;","uniform float outlineAlpha;","void main() {","	#include <clipping_planes_fragment>","	#include <logdepthbuf_fragment>","	gl_FragColor = vec4( outlineColor, outlineAlpha );","	#include <tonemapping_fragment>","	#include <encodings_fragment>","	#include <fog_fragment>","	#include <premultiplied_alpha_fragment>","}"].join(`
`);function b(){return new qe({type:"OutlineEffect",uniforms:ei.merge([en.fog,en.displacementmap,p]),vertexShader:u,fragmentShader:m,side:An})}function T(d){let h=o[d.uuid];return h===void 0&&(h={material:b(),used:!0,keepAlive:r,count:0},o[d.uuid]=h),h.used=!0,h.material}function w(d){const h=T(d);return f[h.uuid]=d,_(h,d),h}function y(d){const h=d.geometry;let S=!1;return d.geometry!==void 0&&(h.isBufferGeometry?S=h.attributes.normal!==void 0:S=!0),d.isMesh===!0&&d.material!==void 0&&S===!0}function x(d){if(y(d)!==!1){if(Array.isArray(d.material))for(let h=0,S=d.material.length;h<S;h++)d.material[h]=w(d.material[h]);else d.material=w(d.material);l[d.uuid]=d.onBeforeRender,d.onBeforeRender=g}}function v(d){if(y(d)!==!1){if(Array.isArray(d.material))for(let h=0,S=d.material.length;h<S;h++)d.material[h]=f[d.material[h].uuid];else d.material=f[d.material.uuid];d.onBeforeRender=l[d.uuid]}}function g(d,h,S,B,C){const E=f[C.uuid];E!==void 0&&A(C,E)}function A(d,h){const S=h.userData.outlineParameters;d.uniforms.outlineAlpha.value=h.opacity,S!==void 0&&(S.thickness!==void 0&&(d.uniforms.outlineThickness.value=S.thickness),S.color!==void 0&&d.uniforms.outlineColor.value.fromArray(S.color),S.alpha!==void 0&&(d.uniforms.outlineAlpha.value=S.alpha)),h.displacementMap&&(d.uniforms.displacementMap.value=h.displacementMap,d.uniforms.displacementScale.value=h.displacementScale,d.uniforms.displacementBias.value=h.displacementBias)}function _(d,h){if(d.name==="invisible")return;const S=h.userData.outlineParameters;d.fog=h.fog,d.toneMapped=h.toneMapped,d.premultipliedAlpha=h.premultipliedAlpha,d.displacementMap=h.displacementMap,S!==void 0?(h.visible===!1?d.visible=!1:d.visible=S.visible!==void 0?S.visible:!0,d.transparent=S.alpha!==void 0&&S.alpha<1?!0:h.transparent,S.keepAlive!==void 0&&(o[h.uuid].keepAlive=S.keepAlive)):(d.transparent=h.transparent,d.visible=h.visible),(h.wireframe===!0||h.depthTest===!1)&&(d.visible=!1),h.clippingPlanes&&(d.clipping=!0,d.clippingPlanes=h.clippingPlanes,d.clipIntersection=h.clipIntersection,d.clipShadows=h.clipShadows),d.version=h.version}function P(){let d;d=Object.keys(f);for(let h=0,S=d.length;h<S;h++)f[d[h]]=void 0;d=Object.keys(l);for(let h=0,S=d.length;h<S;h++)l[d[h]]=void 0;d=Object.keys(o);for(let h=0,S=d.length;h<S;h++){const B=d[h];o[B].used===!1?(o[B].count++,o[B].keepAlive===!1&&o[B].count>c&&delete o[B]):(o[B].used=!1,o[B].count=0)}}this.render=function(d,h){if(this.enabled===!1){e.render(d,h);return}const S=e.autoClear;e.autoClear=this.autoClear,e.render(d,h),e.autoClear=S,this.renderOutline(d,h)},this.renderOutline=function(d,h){const S=e.autoClear,B=d.matrixWorldAutoUpdate,C=d.background,E=e.shadowMap.enabled;d.matrixWorldAutoUpdate=!1,d.background=null,e.autoClear=!1,e.shadowMap.enabled=!1,d.traverse(x),e.render(d,h),d.traverse(v),P(),d.matrixWorldAutoUpdate=B,d.background=C,e.autoClear=S,e.shadowMap.enabled=E},this.autoClear=e.autoClear,this.domElement=e.domElement,this.shadowMap=e.shadowMap,this.clear=function(d,h,S){e.clear(d,h,S)},this.getPixelRatio=function(){return e.getPixelRatio()},this.setPixelRatio=function(d){e.setPixelRatio(d)},this.getSize=function(d){return e.getSize(d)},this.setSize=function(d,h,S){e.setSize(d,h,S)},this.setViewport=function(d,h,S,B){e.setViewport(d,h,S,B)},this.setScissor=function(d,h,S,B){e.setScissor(d,h,S,B)},this.setScissorTest=function(d){e.setScissorTest(d)},this.setRenderTarget=function(d){e.setRenderTarget(d)}}}const bi=M.createContext(null);function wi(n){let{children:e,enabled:t=!0}=n;const[i,s]=M.useState([]),a=M.useMemo(()=>({selected:i,select:s,enabled:t}),[i,s,t]);return et.createElement(bi.Provider,{value:a},e)}const En=0,Ai=1,Si=2,on=2,ge=1.25,cn=1,Ht=6*4+4+4,he=65535,Pi=Math.pow(2,-24),xe=Symbol("SKIP_GENERATION");function _i(n){return n.index?n.index.count:n.attributes.position.count}function Nt(n){return _i(n)/3}function Ti(n,e=ArrayBuffer){return n>65535?new Uint32Array(new e(4*n)):new Uint16Array(new e(2*n))}function Ci(n,e){if(!n.index){const t=n.attributes.position.count,i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Ti(t,i);n.setIndex(new Sn(s,1));for(let a=0;a<t;a++)s[a]=a}}function zn(n){const e=Nt(n),t=n.drawRange,i=t.start/3,s=(t.start+t.count)/3,a=Math.max(0,i),r=Math.min(e,s)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function Nn(n){if(!n.groups||!n.groups.length)return zn(n);const e=[],t=new Set,i=n.drawRange,s=i.start/3,a=(i.start+i.count)/3;for(const o of n.groups){const c=o.start/3,f=(o.start+o.count)/3;t.add(Math.max(s,c)),t.add(Math.min(a,f))}const r=Array.from(t.values()).sort((o,c)=>o-c);for(let o=0;o<r.length-1;o++){const c=r[o],f=r[o+1];e.push({offset:Math.floor(c),count:Math.floor(f-c)})}return e}function Bi(n){if(n.groups.length===0)return!1;const e=Nt(n),t=Nn(n).sort((a,r)=>a.offset-r.offset),i=t[t.length-1];i.count=Math.min(e-i.offset,i.count);let s=0;return t.forEach(({count:a})=>s+=a),e!==s}function ve(n,e,t,i,s){let a=1/0,r=1/0,o=1/0,c=-1/0,f=-1/0,l=-1/0,p=1/0,u=1/0,m=1/0,b=-1/0,T=-1/0,w=-1/0;for(let y=e*6,x=(e+t)*6;y<x;y+=6){const v=n[y+0],g=n[y+1],A=v-g,_=v+g;A<a&&(a=A),_>c&&(c=_),v<p&&(p=v),v>b&&(b=v);const P=n[y+2],d=n[y+3],h=P-d,S=P+d;h<r&&(r=h),S>f&&(f=S),P<u&&(u=P),P>T&&(T=P);const B=n[y+4],C=n[y+5],E=B-C,U=B+C;E<o&&(o=E),U>l&&(l=U),B<m&&(m=B),B>w&&(w=B)}i[0]=a,i[1]=r,i[2]=o,i[3]=c,i[4]=f,i[5]=l,s[0]=p,s[1]=u,s[2]=m,s[3]=b,s[4]=T,s[5]=w}function Mi(n,e=null,t=null,i=null){const s=n.attributes.position,a=n.index?n.index.array:null,r=Nt(n),o=s.normalized;let c;e===null?(c=new Float32Array(r*6*4),t=0,i=r):(c=e,t=t||0,i=i||r);const f=s.array,l=s.offset||0;let p=3;s.isInterleavedBufferAttribute&&(p=s.data.stride);const u=["getX","getY","getZ"];for(let m=t;m<t+i;m++){const b=m*3,T=m*6;let w=b+0,y=b+1,x=b+2;a&&(w=a[w],y=a[y],x=a[x]),o||(w=w*p+l,y=y*p+l,x=x*p+l);for(let v=0;v<3;v++){let g,A,_;o?(g=s[u[v]](w),A=s[u[v]](y),_=s[u[v]](x)):(g=f[w+v],A=f[y+v],_=f[x+v]);let P=g;A<P&&(P=A),_<P&&(P=_);let d=g;A>d&&(d=A),_>d&&(d=_);const h=(d-P)/2,S=v*2;c[T+S+0]=P+h,c[T+S+1]=h+(Math.abs(P)+h)*Pi}}return c}function R(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function an(n){let e=-1,t=-1/0;for(let i=0;i<3;i++){const s=n[i+3]-n[i];s>t&&(t=s,e=i)}return e}function ln(n,e){e.set(n)}function un(n,e,t){let i,s;for(let a=0;a<3;a++){const r=a+3;i=n[a],s=e[a],t[a]=i<s?i:s,i=n[r],s=e[r],t[r]=i>s?i:s}}function Gt(n,e,t){for(let i=0;i<3;i++){const s=e[n+2*i],a=e[n+2*i+1],r=s-a,o=s+a;r<t[i]&&(t[i]=r),o>t[i+3]&&(t[i+3]=o)}}function Ut(n){const e=n[3]-n[0],t=n[4]-n[1],i=n[5]-n[2];return 2*(e*t+t*i+i*e)}const ot=32,Ei=(n,e)=>n.candidate-e.candidate,ut=new Array(ot).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Kt=new Float32Array(6);function zi(n,e,t,i,s,a){let r=-1,o=0;if(a===En)r=an(e),r!==-1&&(o=(e[r]+e[r+3])/2);else if(a===Ai)r=an(n),r!==-1&&(o=Ni(t,i,s,r));else if(a===Si){const c=Ut(n);let f=ge*s;const l=i*6,p=(i+s)*6;for(let u=0;u<3;u++){const m=e[u],w=(e[u+3]-m)/ot;if(s<ot/4){const y=[...ut];y.length=s;let x=0;for(let g=l;g<p;g+=6,x++){const A=y[x];A.candidate=t[g+2*u],A.count=0;const{bounds:_,leftCacheBounds:P,rightCacheBounds:d}=A;for(let h=0;h<3;h++)d[h]=1/0,d[h+3]=-1/0,P[h]=1/0,P[h+3]=-1/0,_[h]=1/0,_[h+3]=-1/0;Gt(g,t,_)}y.sort(Ei);let v=s;for(let g=0;g<v;g++){const A=y[g];for(;g+1<v&&y[g+1].candidate===A.candidate;)y.splice(g+1,1),v--}for(let g=l;g<p;g+=6){const A=t[g+2*u];for(let _=0;_<v;_++){const P=y[_];A>=P.candidate?Gt(g,t,P.rightCacheBounds):(Gt(g,t,P.leftCacheBounds),P.count++)}}for(let g=0;g<v;g++){const A=y[g],_=A.count,P=s-A.count,d=A.leftCacheBounds,h=A.rightCacheBounds;let S=0;_!==0&&(S=Ut(d)/c);let B=0;P!==0&&(B=Ut(h)/c);const C=cn+ge*(S*_+B*P);C<f&&(r=u,f=C,o=A.candidate)}}else{for(let v=0;v<ot;v++){const g=ut[v];g.count=0,g.candidate=m+w+v*w;const A=g.bounds;for(let _=0;_<3;_++)A[_]=1/0,A[_+3]=-1/0}for(let v=l;v<p;v+=6){let _=~~((t[v+2*u]-m)/w);_>=ot&&(_=ot-1);const P=ut[_];P.count++,Gt(v,t,P.bounds)}const y=ut[ot-1];ln(y.bounds,y.rightCacheBounds);for(let v=ot-2;v>=0;v--){const g=ut[v],A=ut[v+1];un(g.bounds,A.rightCacheBounds,g.rightCacheBounds)}let x=0;for(let v=0;v<ot-1;v++){const g=ut[v],A=g.count,_=g.bounds,d=ut[v+1].rightCacheBounds;A!==0&&(x===0?ln(_,Kt):un(_,Kt,Kt)),x+=A;let h=0,S=0;x!==0&&(h=Ut(Kt)/c);const B=s-x;B!==0&&(S=Ut(d)/c);const C=cn+ge*(h*x+S*B);C<f&&(r=u,f=C,o=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:o}}function Ni(n,e,t,i){let s=0;for(let a=e,r=e+t;a<r;a++)s+=n[a*6+i*2];return s/t}class be{constructor(){this.boundingData=new Float32Array(6)}}function ki(n,e,t,i,s,a){let r=i,o=i+s-1;const c=a.pos,f=a.axis*2;for(;;){for(;r<=o&&t[r*6+f]<c;)r++;for(;r<=o&&t[o*6+f]>=c;)o--;if(r<o){for(let l=0;l<3;l++){let p=e[r*3+l];e[r*3+l]=e[o*3+l],e[o*3+l]=p}for(let l=0;l<6;l++){let p=t[r*6+l];t[r*6+l]=t[o*6+l],t[o*6+l]=p}r++,o--}else return r}}function Ui(n,e,t,i,s,a){let r=i,o=i+s-1;const c=a.pos,f=a.axis*2;for(;;){for(;r<=o&&t[r*6+f]<c;)r++;for(;r<=o&&t[o*6+f]>=c;)o--;if(r<o){let l=n[r];n[r]=n[o],n[o]=l;for(let p=0;p<6;p++){let u=t[r*6+p];t[r*6+p]=t[o*6+p],t[o*6+p]=u}r++,o--}else return r}}function H(n,e){return e[n+15]===65535}function G(n,e){return e[n+6]}function K(n,e){return e[n+14]}function Z(n){return n+8}function J(n,e){return e[n+6]}function kn(n,e){return e[n+7]}let Un,qt,ue,On;const Oi=Math.pow(2,32);function ke(n){return"count"in n?1:1+ke(n.left)+ke(n.right)}function Li(n,e,t){return Un=new Float32Array(t),qt=new Uint32Array(t),ue=new Uint16Array(t),On=new Uint8Array(t),Ue(n,e)}function Ue(n,e){const t=n/4,i=n/2,s="count"in e,a=e.boundingData;for(let r=0;r<6;r++)Un[t+r]=a[r];if(s)if(e.buffer){const r=e.buffer;On.set(new Uint8Array(r),n);for(let o=n,c=n+r.byteLength;o<c;o+=Ht){const f=o/2;H(f,ue)||(qt[o/4+6]+=t)}return n+r.byteLength}else{const r=e.offset,o=e.count;return qt[t+6]=r,ue[i+14]=o,ue[i+15]=he,n+Ht}else{const r=e.left,o=e.right,c=e.splitAxis;let f;if(f=Ue(n+Ht,r),f/4>Oi)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return qt[t+6]=f/4,f=Ue(f,o),qt[t+7]=c,f}}function Di(n,e){const t=(n.index?n.index.count:n.attributes.position.count)/3,i=t>2**16,s=i?4:2,a=e?new SharedArrayBuffer(t*s):new ArrayBuffer(t*s),r=i?new Uint32Array(a):new Uint16Array(a);for(let o=0,c=r.length;o<c;o++)r[o]=o;return r}function Vi(n,e,t,i,s){const{maxDepth:a,verbose:r,maxLeafTris:o,strategy:c,onProgress:f,indirect:l}=s,p=n._indirectBuffer,u=n.geometry,m=u.index?u.index.array:null,b=l?Ui:ki,T=Nt(u),w=new Float32Array(6);let y=!1;const x=new be;return ve(e,t,i,x.boundingData,w),g(x,t,i,w),x;function v(A){f&&f(A/T)}function g(A,_,P,d=null,h=0){if(!y&&h>=a&&(y=!0,r&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(u))),P<=o||h>=a)return v(_+P),A.offset=_,A.count=P,A;const S=zi(A.boundingData,d,e,_,P,c);if(S.axis===-1)return v(_+P),A.offset=_,A.count=P,A;const B=b(p,m,e,_,P,S);if(B===_||B===_+P)v(_+P),A.offset=_,A.count=P;else{A.splitAxis=S.axis;const C=new be,E=_,U=B-_;A.left=C,ve(e,E,U,C.boundingData,w),g(C,E,U,w,h+1);const D=new be,L=B,X=P-U;A.right=D,ve(e,L,X,D.boundingData,w),g(D,L,X,w,h+1)}return A}}function Ri(n,e){const t=n.geometry;e.indirect&&(n._indirectBuffer=Di(t,e.useSharedArrayBuffer),Bi(t)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Ci(t,e);const i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Mi(t),a=e.indirect?zn(t):Nn(t);n._roots=a.map(r=>{const o=Vi(n,s,r.offset,r.count,e),c=ke(o),f=new i(Ht*c);return Li(0,o,f),f})}class at{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let i=1/0,s=-1/0;for(let a=0,r=e.length;a<r;a++){const c=e[a][t];i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}setFromPoints(e,t){let i=1/0,s=-1/0;for(let a=0,r=t.length;a<r;a++){const o=t[a],c=e.dot(o);i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}isSeparated(e){return this.min>e.max||e.min>this.max}}at.prototype.setFromBox=function(){const n=new k;return function(t,i){const s=i.min,a=i.max;let r=1/0,o=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){n.x=s.x*c+a.x*(1-c),n.y=s.y*f+a.y*(1-f),n.z=s.z*l+a.z*(1-l);const p=t.dot(n);r=Math.min(p,r),o=Math.max(p,o)}this.min=r,this.max=o}}();const ji=function(){const n=new k,e=new k,t=new k;return function(s,a,r){const o=s.start,c=n,f=a.start,l=e;t.subVectors(o,f),n.subVectors(s.end,s.start),e.subVectors(a.end,a.start);const p=t.dot(l),u=l.dot(c),m=l.dot(l),b=t.dot(c),w=c.dot(c)*m-u*u;let y,x;w!==0?y=(p*u-b*m)/w:y=0,x=(p+y*u)/m,r.x=y,r.y=x}}(),$e=function(){const n=new zt,e=new k,t=new k;return function(s,a,r,o){ji(s,a,n);let c=n.x,f=n.y;if(c>=0&&c<=1&&f>=0&&f<=1){s.at(c,r),a.at(f,o);return}else if(c>=0&&c<=1){f<0?a.at(0,o):a.at(1,o),s.closestPointToPoint(o,!0,r);return}else if(f>=0&&f<=1){c<0?s.at(0,r):s.at(1,r),a.closestPointToPoint(r,!0,o);return}else{let l;c<0?l=s.start:l=s.end;let p;f<0?p=a.start:p=a.end;const u=e,m=t;if(s.closestPointToPoint(p,!0,e),a.closestPointToPoint(l,!0,t),u.distanceToSquared(p)<=m.distanceToSquared(l)){r.copy(u),o.copy(p);return}else{r.copy(l),o.copy(m);return}}}}(),Fi=function(){const n=new k,e=new k,t=new Pn,i=new ct;return function(a,r){const{radius:o,center:c}=a,{a:f,b:l,c:p}=r;if(i.start=f,i.end=l,i.closestPointToPoint(c,!0,n).distanceTo(c)<=o||(i.start=f,i.end=p,i.closestPointToPoint(c,!0,n).distanceTo(c)<=o)||(i.start=l,i.end=p,i.closestPointToPoint(c,!0,n).distanceTo(c)<=o))return!0;const T=r.getPlane(t);if(Math.abs(T.distanceToPoint(c))<=o){const y=T.projectPoint(c,e);if(r.containsPoint(y))return!0}return!1}}(),Ii=1e-15;function we(n){return Math.abs(n)<Ii}class it extends Ft{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new k),this.satBounds=new Array(4).fill().map(()=>new at),this.points=[this.a,this.b,this.c],this.sphere=new ni,this.plane=new Pn,this.needsUpdate=!0}intersectsSphere(e){return Fi(e,this)}update(){const e=this.a,t=this.b,i=this.c,s=this.points,a=this.satAxes,r=this.satBounds,o=a[0],c=r[0];this.getNormal(o),c.setFromPoints(o,s);const f=a[1],l=r[1];f.subVectors(e,t),l.setFromPoints(f,s);const p=a[2],u=r[2];p.subVectors(t,i),u.setFromPoints(p,s);const m=a[3],b=r[3];m.subVectors(i,e),b.setFromPoints(m,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,e),this.needsUpdate=!1}}it.prototype.closestPointToSegment=function(){const n=new k,e=new k,t=new ct;return function(s,a=null,r=null){const{start:o,end:c}=s,f=this.points;let l,p=1/0;for(let u=0;u<3;u++){const m=(u+1)%3;t.start.copy(f[u]),t.end.copy(f[m]),$e(t,s,n,e),l=n.distanceToSquared(e),l<p&&(p=l,a&&a.copy(n),r&&r.copy(e))}return this.closestPointToPoint(o,n),l=o.distanceToSquared(n),l<p&&(p=l,a&&a.copy(n),r&&r.copy(o)),this.closestPointToPoint(c,n),l=c.distanceToSquared(n),l<p&&(p=l,a&&a.copy(n),r&&r.copy(c)),Math.sqrt(p)}}();it.prototype.intersectsTriangle=function(){const n=new it,e=new Array(3),t=new Array(3),i=new at,s=new at,a=new k,r=new k,o=new k,c=new k,f=new k,l=new ct,p=new ct,u=new ct,m=new k;function b(T,w,y){const x=T.points;let v=0,g=-1;for(let A=0;A<3;A++){const{start:_,end:P}=l;_.copy(x[A]),P.copy(x[(A+1)%3]),l.delta(r);const d=we(w.distanceToPoint(_));if(we(w.normal.dot(r))&&d){y.copy(l),v=2;break}const h=w.intersectLine(l,m);if(!h&&d&&m.copy(_),(h||d)&&!we(m.distanceTo(P))){if(v<=1)(v===1?y.start:y.end).copy(m),d&&(g=v);else if(v>=2){(g===1?y.start:y.end).copy(m),v=2;break}if(v++,v===2&&g===-1)break}}return v}return function(w,y=null,x=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(n.copy(w),n.update(),w=n);const v=this.plane,g=w.plane;if(Math.abs(v.normal.dot(g.normal))>1-1e-10){const A=this.satBounds,_=this.satAxes;t[0]=w.a,t[1]=w.b,t[2]=w.c;for(let h=0;h<4;h++){const S=A[h],B=_[h];if(i.setFromPoints(B,t),S.isSeparated(i))return!1}const P=w.satBounds,d=w.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let h=0;h<4;h++){const S=P[h],B=d[h];if(i.setFromPoints(B,e),S.isSeparated(i))return!1}for(let h=0;h<4;h++){const S=_[h];for(let B=0;B<4;B++){const C=d[B];if(a.crossVectors(S,C),i.setFromPoints(a,e),s.setFromPoints(a,t),i.isSeparated(s))return!1}}return y&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const A=b(this,g,p);if(A===1&&w.containsPoint(p.end))return y&&(y.start.copy(p.end),y.end.copy(p.end)),!0;if(A!==2)return!1;const _=b(w,v,u);if(_===1&&this.containsPoint(u.end))return y&&(y.start.copy(u.end),y.end.copy(u.end)),!0;if(_!==2)return!1;if(p.delta(o),u.delta(c),o.dot(c)<0){let E=u.start;u.start=u.end,u.end=E}const P=p.start.dot(o),d=p.end.dot(o),h=u.start.dot(o),S=u.end.dot(o),B=d<h,C=P<S;return P!==S&&h!==d&&B===C?!1:(y&&(f.subVectors(p.start,u.start),f.dot(o)>0?y.start.copy(p.start):y.start.copy(u.start),f.subVectors(p.end,u.end),f.dot(o)<0?y.end.copy(p.end):y.end.copy(u.end)),!0)}}}();it.prototype.distanceToPoint=function(){const n=new k;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();it.prototype.distanceToTriangle=function(){const n=new k,e=new k,t=["a","b","c"],i=new ct,s=new ct;return function(r,o=null,c=null){const f=o||c?i:null;if(this.intersectsTriangle(r,f))return(o||c)&&(o&&f.getCenter(o),c&&f.getCenter(c)),0;let l=1/0;for(let p=0;p<3;p++){let u;const m=t[p],b=r[m];this.closestPointToPoint(b,n),u=b.distanceToSquared(n),u<l&&(l=u,o&&o.copy(n),c&&c.copy(b));const T=this[m];r.closestPointToPoint(T,n),u=T.distanceToSquared(n),u<l&&(l=u,o&&o.copy(T),c&&c.copy(n))}for(let p=0;p<3;p++){const u=t[p],m=t[(p+1)%3];i.set(this[u],this[m]);for(let b=0;b<3;b++){const T=t[b],w=t[(b+1)%3];s.set(r[T],r[w]),$e(i,s,n,e);const y=n.distanceToSquared(e);y<l&&(l=y,o&&o.copy(n),c&&c.copy(e))}}return Math.sqrt(l)}}();class ${constructor(e,t,i){this.isOrientedBox=!0,this.min=new k,this.max=new k,this.matrix=new mt,this.invMatrix=new mt,this.points=new Array(8).fill().map(()=>new k),this.satAxes=new Array(3).fill().map(()=>new k),this.satBounds=new Array(3).fill().map(()=>new at),this.alignedSatBounds=new Array(3).fill().map(()=>new at),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),i&&this.matrix.copy(i)}set(e,t,i){this.min.copy(e),this.max.copy(t),this.matrix.copy(i),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}$.prototype.update=function(){return function(){const e=this.matrix,t=this.min,i=this.max,s=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const u=1*f|2*l|4*p,m=s[u];m.x=f?i.x:t.x,m.y=l?i.y:t.y,m.z=p?i.z:t.z,m.applyMatrix4(e)}const a=this.satBounds,r=this.satAxes,o=s[0];for(let f=0;f<3;f++){const l=r[f],p=a[f],u=1<<f,m=s[u];l.subVectors(o,m),p.setFromPoints(l,s)}const c=this.alignedSatBounds;c[0].setFromPointsField(s,"x"),c[1].setFromPointsField(s,"y"),c[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();$.prototype.intersectsBox=function(){const n=new at;return function(t){this.needsUpdate&&this.update();const i=t.min,s=t.max,a=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(n.min=i.x,n.max=s.x,o[0].isSeparated(n)||(n.min=i.y,n.max=s.y,o[1].isSeparated(n))||(n.min=i.z,n.max=s.z,o[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const f=r[c],l=a[c];if(n.setFromBox(f,t),l.isSeparated(n))return!1}return!0}}();$.prototype.intersectsTriangle=function(){const n=new it,e=new Array(3),t=new at,i=new at,s=new k;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const o=this.satBounds,c=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let u=0;u<3;u++){const m=o[u],b=c[u];if(t.setFromPoints(b,e),m.isSeparated(t))return!1}const f=r.satBounds,l=r.satAxes,p=this.points;for(let u=0;u<3;u++){const m=f[u],b=l[u];if(t.setFromPoints(b,p),m.isSeparated(t))return!1}for(let u=0;u<3;u++){const m=c[u];for(let b=0;b<4;b++){const T=l[b];if(s.crossVectors(m,T),t.setFromPoints(s,e),i.setFromPoints(s,p),t.isSeparated(i))return!1}}return!0}}();$.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();$.prototype.distanceToPoint=function(){const n=new k;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}}();$.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new ct),t=new Array(12).fill().map(()=>new ct),i=new k,s=new k;return function(r,o=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||f)&&(r.getCenter(s),this.closestPointToPoint(s,i),r.closestPointToPoint(i,s),c&&c.copy(i),f&&f.copy(s)),0;const l=o*o,p=r.min,u=r.max,m=this.points;let b=1/0;for(let w=0;w<8;w++){const y=m[w];s.copy(y).clamp(p,u);const x=y.distanceToSquared(s);if(x<b&&(b=x,c&&c.copy(y),f&&f.copy(s),x<l))return Math.sqrt(x)}let T=0;for(let w=0;w<3;w++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){const v=(w+1)%3,g=(w+2)%3,A=y<<v|x<<g,_=1<<w|y<<v|x<<g,P=m[A],d=m[_];e[T].set(P,d);const S=n[w],B=n[v],C=n[g],E=t[T],U=E.start,D=E.end;U[S]=p[S],U[B]=y?p[B]:u[B],U[C]=x?p[C]:u[B],D[S]=u[S],D[B]=y?p[B]:u[B],D[C]=x?p[C]:u[B],T++}for(let w=0;w<=1;w++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){s.x=w?u.x:p.x,s.y=y?u.y:p.y,s.z=x?u.z:p.z,this.closestPointToPoint(s,i);const v=s.distanceToSquared(i);if(v<b&&(b=v,c&&c.copy(i),f&&f.copy(s),v<l))return Math.sqrt(v)}for(let w=0;w<12;w++){const y=e[w];for(let x=0;x<12;x++){const v=t[x];$e(y,v,i,s);const g=i.distanceToSquared(s);if(g<b&&(b=g,c&&c.copy(i),f&&f.copy(s),g<l))return Math.sqrt(g)}}return Math.sqrt(b)}}();class He{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class qi extends He{constructor(){super(()=>new it)}}const Y=new qi;class $i{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=i=>{t&&e.push(t),t=i,this.float32Array=new Float32Array(i),this.uint16Array=new Uint16Array(i),this.uint32Array=new Uint32Array(i)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const V=new $i;let dt,Et;const vt=[],Zt=new He(()=>new rt);function Hi(n,e,t,i,s,a){dt=Zt.getPrimitive(),Et=Zt.getPrimitive(),vt.push(dt,Et),V.setBuffer(n._roots[e]);const r=Oe(0,n.geometry,t,i,s,a);V.clearBuffer(),Zt.releasePrimitive(dt),Zt.releasePrimitive(Et),vt.pop(),vt.pop();const o=vt.length;return o>0&&(Et=vt[o-1],dt=vt[o-2]),r}function Oe(n,e,t,i,s=null,a=0,r=0){const{float32Array:o,uint16Array:c,uint32Array:f}=V;let l=n*2;if(H(l,c)){const u=G(n,f),m=K(l,c);return R(n,o,dt),i(u,m,!1,r,a+n,dt)}else{let S=function(C){const{uint16Array:E,uint32Array:U}=V;let D=C*2;for(;!H(D,E);)C=Z(C),D=C*2;return G(C,U)},B=function(C){const{uint16Array:E,uint32Array:U}=V;let D=C*2;for(;!H(D,E);)C=J(C,U),D=C*2;return G(C,U)+K(D,E)};const u=Z(n),m=J(n,f);let b=u,T=m,w,y,x,v;if(s&&(x=dt,v=Et,R(b,o,x),R(T,o,v),w=s(x),y=s(v),y<w)){b=m,T=u;const C=w;w=y,y=C,x=v}x||(x=dt,R(b,o,x));const g=H(b*2,c),A=t(x,g,w,r+1,a+b);let _;if(A===on){const C=S(b),U=B(b)-C;_=i(C,U,!0,r+1,a+b,x)}else _=A&&Oe(b,e,t,i,s,a,r+1);if(_)return!0;v=Et,R(T,o,v);const P=H(T*2,c),d=t(v,P,y,r+1,a+T);let h;if(d===on){const C=S(T),U=B(T)-C;h=i(C,U,!0,r+1,a+T,v)}else h=d&&Oe(T,e,t,i,s,a,r+1);return!!h}}const Ot=new k,Ae=new k;function Wi(n,e,t={},i=0,s=1/0){const a=i*i,r=s*s;let o=1/0,c=null;if(n.shapecast({boundsTraverseOrder:l=>(Ot.copy(e).clamp(l.min,l.max),Ot.distanceToSquared(e)),intersectsBounds:(l,p,u)=>u<o&&u<r,intersectsTriangle:(l,p)=>{l.closestPointToPoint(e,Ot);const u=e.distanceToSquared(Ot);return u<o&&(Ae.copy(Ot),o=u,c=p),u<a}}),o===1/0)return null;const f=Math.sqrt(o);return t.point?t.point.copy(Ae):t.point=Ae.clone(),t.distance=f,t.faceIndex=c,t}const bt=new k,wt=new k,At=new k,Jt=new zt,Yt=new zt,Qt=new zt,fn=new k,pn=new k,dn=new k,te=new k;function Xi(n,e,t,i,s,a){let r;return a===An?r=n.intersectTriangle(i,t,e,!0,s):r=n.intersectTriangle(e,t,i,a!==ii,s),r===null?null:{distance:n.origin.distanceTo(s),point:s.clone()}}function Gi(n,e,t,i,s,a,r,o,c){bt.fromBufferAttribute(e,a),wt.fromBufferAttribute(e,r),At.fromBufferAttribute(e,o);const f=Xi(n,bt,wt,At,te,c);if(f){i&&(Jt.fromBufferAttribute(i,a),Yt.fromBufferAttribute(i,r),Qt.fromBufferAttribute(i,o),f.uv=Ft.getInterpolation(te,bt,wt,At,Jt,Yt,Qt,new zt)),s&&(Jt.fromBufferAttribute(s,a),Yt.fromBufferAttribute(s,r),Qt.fromBufferAttribute(s,o),f.uv1=Ft.getInterpolation(te,bt,wt,At,Jt,Yt,Qt,new zt)),t&&(fn.fromBufferAttribute(t,a),pn.fromBufferAttribute(t,r),dn.fromBufferAttribute(t,o),f.normal=Ft.getInterpolation(te,bt,wt,At,fn,pn,dn,new k),f.normal.dot(n.direction)>0&&f.normal.multiplyScalar(-1));const l={a,b:r,c:o,normal:new k,materialIndex:0};Ft.getNormal(bt,wt,At,l.normal),f.face=l,f.faceIndex=a}return f}function ye(n,e,t,i,s){const a=i*3;let r=a+0,o=a+1,c=a+2;const f=n.index;n.index&&(r=f.getX(r),o=f.getX(o),c=f.getX(c));const{position:l,normal:p,uv:u,uv1:m}=n.attributes,b=Gi(t,l,p,u,m,r,o,c,e);return b?(b.faceIndex=i,s&&s.push(b),b):null}function I(n,e,t,i){const s=n.a,a=n.b,r=n.c;let o=e,c=e+1,f=e+2;t&&(o=t.getX(o),c=t.getX(c),f=t.getX(f)),s.x=i.getX(o),s.y=i.getY(o),s.z=i.getZ(o),a.x=i.getX(c),a.y=i.getY(c),a.z=i.getZ(c),r.x=i.getX(f),r.y=i.getY(f),r.z=i.getZ(f)}function Ki(n,e,t,i,s,a){const{geometry:r,_indirectBuffer:o}=n;for(let c=i,f=i+s;c<f;c++)ye(r,e,t,c,a)}function Zi(n,e,t,i,s){const{geometry:a,_indirectBuffer:r}=n;let o=1/0,c=null;for(let f=i,l=i+s;f<l;f++){let p;p=ye(a,e,t,f),p&&p.distance<o&&(c=p,o=p.distance)}return c}function Ji(n,e,t,i,s,a,r){const{geometry:o}=t,{index:c}=o,f=o.attributes.position;for(let l=n,p=e+n;l<p;l++){let u;if(u=l,I(r,u*3,c,f),r.needsUpdate=!0,i(r,u,s,a))return!0}return!1}function Yi(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,i=t.index?t.index.array:null,s=t.attributes.position;let a,r,o,c,f=0;const l=n._roots;for(let u=0,m=l.length;u<m;u++)a=l[u],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),p(0,f),f+=a.byteLength;function p(u,m,b=!1){const T=u*2;if(o[T+15]===he){const y=r[u+6],x=o[T+14];let v=1/0,g=1/0,A=1/0,_=-1/0,P=-1/0,d=-1/0;for(let h=3*y,S=3*(y+x);h<S;h++){let B=i[h];const C=s.getX(B),E=s.getY(B),U=s.getZ(B);C<v&&(v=C),C>_&&(_=C),E<g&&(g=E),E>P&&(P=E),U<A&&(A=U),U>d&&(d=U)}return c[u+0]!==v||c[u+1]!==g||c[u+2]!==A||c[u+3]!==_||c[u+4]!==P||c[u+5]!==d?(c[u+0]=v,c[u+1]=g,c[u+2]=A,c[u+3]=_,c[u+4]=P,c[u+5]=d,!0):!1}else{const y=u+8,x=r[u+6],v=y+m,g=x+m;let A=b,_=!1,P=!1;e?A||(_=e.has(v),P=e.has(g),A=!_&&!P):(_=!0,P=!0);const d=A||_,h=A||P;let S=!1;d&&(S=p(y,m,A));let B=!1;h&&(B=p(x,m,A));const C=S||B;if(C)for(let E=0;E<3;E++){const U=y+E,D=x+E,L=c[U],X=c[U+3],lt=c[D],yt=c[D+3];c[u+E]=L<lt?L:lt,c[u+E+3]=X>yt?X:yt}return C}}}function ht(n,e,t){let i,s,a,r,o,c;const f=1/t.direction.x,l=1/t.direction.y,p=1/t.direction.z,u=t.origin.x,m=t.origin.y,b=t.origin.z;let T=e[n],w=e[n+3],y=e[n+1],x=e[n+3+1],v=e[n+2],g=e[n+3+2];return f>=0?(i=(T-u)*f,s=(w-u)*f):(i=(w-u)*f,s=(T-u)*f),l>=0?(a=(y-m)*l,r=(x-m)*l):(a=(x-m)*l,r=(y-m)*l),!(i>r||a>s||((a>i||isNaN(i))&&(i=a),(r<s||isNaN(s))&&(s=r),p>=0?(o=(v-b)*p,c=(g-b)*p):(o=(g-b)*p,c=(v-b)*p),i>c||o>s)||((c<s||s!==s)&&(s=c),s<0))}function Qi(n,e,t,i,s,a){const{geometry:r,_indirectBuffer:o}=n;for(let c=i,f=i+s;c<f;c++){let l=o?o[c]:c;ye(r,e,t,l,a)}}function ts(n,e,t,i,s){const{geometry:a,_indirectBuffer:r}=n;let o=1/0,c=null;for(let f=i,l=i+s;f<l;f++){let p;p=ye(a,e,t,r?r[f]:f),p&&p.distance<o&&(c=p,o=p.distance)}return c}function es(n,e,t,i,s,a,r){const{geometry:o}=t,{index:c}=o,f=o.attributes.position;for(let l=n,p=e+n;l<p;l++){let u;if(u=t.resolveTriangleIndex(l),I(r,u*3,c,f),r.needsUpdate=!0,i(r,u,s,a))return!0}return!1}function ns(n,e,t,i,s){V.setBuffer(n._roots[e]),Le(0,n,t,i,s),V.clearBuffer()}function Le(n,e,t,i,s){const{float32Array:a,uint16Array:r,uint32Array:o}=V,c=n*2;if(H(c,r)){const l=G(n,o),p=K(c,r);Ki(e,t,i,l,p,s)}else{const l=Z(n);ht(l,a,i)&&Le(l,e,t,i,s);const p=J(n,o);ht(p,a,i)&&Le(p,e,t,i,s)}}const is=["x","y","z"];function ss(n,e,t,i){V.setBuffer(n._roots[e]);const s=De(0,n,t,i);return V.clearBuffer(),s}function De(n,e,t,i){const{float32Array:s,uint16Array:a,uint32Array:r}=V;let o=n*2;if(H(o,a)){const f=G(n,r),l=K(o,a);return Zi(e,t,i,f,l)}else{const f=kn(n,r),l=is[f],u=i.direction[l]>=0;let m,b;u?(m=Z(n),b=J(n,r)):(m=J(n,r),b=Z(n));const w=ht(m,s,i)?De(m,e,t,i):null;if(w){const v=w.point[l];if(u?v<=s[b+f]:v>=s[b+f+3])return w}const x=ht(b,s,i)?De(b,e,t,i):null;return w&&x?w.distance<=x.distance?w:x:w||x||null}}const ee=new rt,St=new it,Pt=new it,Lt=new mt,mn=new $,ne=new $;function rs(n,e,t,i){V.setBuffer(n._roots[e]);const s=Ve(0,n,t,i);return V.clearBuffer(),s}function Ve(n,e,t,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:o}=V;let c=n*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),mn.set(t.boundingBox.min,t.boundingBox.max,i),s=mn),H(c,r)){const l=e.geometry,p=l.index,u=l.attributes.position,m=t.index,b=t.attributes.position,T=G(n,o),w=K(c,r);if(Lt.copy(i).invert(),t.boundsTree)return R(n,a,ne),ne.matrix.copy(Lt),ne.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>ne.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(i),x.b.applyMatrix4(i),x.c.applyMatrix4(i),x.needsUpdate=!0;for(let v=T*3,g=(w+T)*3;v<g;v+=3)if(I(Pt,v,p,u),Pt.needsUpdate=!0,x.intersectsTriangle(Pt))return!0;return!1}});for(let y=T*3,x=(w+T)*3;y<x;y+=3){I(St,y,p,u),St.a.applyMatrix4(Lt),St.b.applyMatrix4(Lt),St.c.applyMatrix4(Lt),St.needsUpdate=!0;for(let v=0,g=m.count;v<g;v+=3)if(I(Pt,v,m,b),Pt.needsUpdate=!0,St.intersectsTriangle(Pt))return!0}}else{const l=n+8,p=o[n+6];return R(l,a,ee),!!(s.intersectsBox(ee)&&Ve(l,e,t,i,s)||(R(p,a,ee),s.intersectsBox(ee)&&Ve(p,e,t,i,s)))}}const ie=new mt,Se=new $,Dt=new $,os=new k,cs=new k,as=new k,ls=new k;function us(n,e,t,i={},s={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),Se.set(e.boundingBox.min,e.boundingBox.max,t),Se.needsUpdate=!0;const o=n.geometry,c=o.attributes.position,f=o.index,l=e.attributes.position,p=e.index,u=Y.getPrimitive(),m=Y.getPrimitive();let b=os,T=cs,w=null,y=null;s&&(w=as,y=ls);let x=1/0,v=null,g=null;return ie.copy(t).invert(),Dt.matrix.copy(ie),n.shapecast({boundsTraverseOrder:A=>Se.distanceToBox(A),intersectsBounds:(A,_,P)=>P<x&&P<r?(_&&(Dt.min.copy(A.min),Dt.max.copy(A.max),Dt.needsUpdate=!0),!0):!1,intersectsRange:(A,_)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:d=>Dt.distanceToBox(d),intersectsBounds:(d,h,S)=>S<x&&S<r,intersectsRange:(d,h)=>{for(let S=d,B=d+h;S<B;S++){I(m,3*S,p,l),m.a.applyMatrix4(t),m.b.applyMatrix4(t),m.c.applyMatrix4(t),m.needsUpdate=!0;for(let C=A,E=A+_;C<E;C++){I(u,3*C,f,c),u.needsUpdate=!0;const U=u.distanceToTriangle(m,b,w);if(U<x&&(T.copy(b),y&&y.copy(w),x=U,v=C,g=S),U<a)return!0}}}});{const P=Nt(e);for(let d=0,h=P;d<h;d++){I(m,3*d,p,l),m.a.applyMatrix4(t),m.b.applyMatrix4(t),m.c.applyMatrix4(t),m.needsUpdate=!0;for(let S=A,B=A+_;S<B;S++){I(u,3*S,f,c),u.needsUpdate=!0;const C=u.distanceToTriangle(m,b,w);if(C<x&&(T.copy(b),y&&y.copy(w),x=C,v=S,g=d),C<a)return!0}}}}}),Y.releasePrimitive(u),Y.releasePrimitive(m),x===1/0?null:(i.point?i.point.copy(T):i.point=T.clone(),i.distance=x,i.faceIndex=v,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(ie),T.applyMatrix4(ie),s.distance=T.sub(s.point).length(),s.faceIndex=g),i)}function fs(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,i=t.index?t.index.array:null,s=t.attributes.position;let a,r,o,c,f=0;const l=n._roots;for(let u=0,m=l.length;u<m;u++)a=l[u],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),p(0,f),f+=a.byteLength;function p(u,m,b=!1){const T=u*2;if(o[T+15]===he){const y=r[u+6],x=o[T+14];let v=1/0,g=1/0,A=1/0,_=-1/0,P=-1/0,d=-1/0;for(let h=y,S=y+x;h<S;h++){const B=3*n.resolveTriangleIndex(h);for(let C=0;C<3;C++){let E=B+C;E=i?i[E]:E;const U=s.getX(E),D=s.getY(E),L=s.getZ(E);U<v&&(v=U),U>_&&(_=U),D<g&&(g=D),D>P&&(P=D),L<A&&(A=L),L>d&&(d=L)}}return c[u+0]!==v||c[u+1]!==g||c[u+2]!==A||c[u+3]!==_||c[u+4]!==P||c[u+5]!==d?(c[u+0]=v,c[u+1]=g,c[u+2]=A,c[u+3]=_,c[u+4]=P,c[u+5]=d,!0):!1}else{const y=u+8,x=r[u+6],v=y+m,g=x+m;let A=b,_=!1,P=!1;e?A||(_=e.has(v),P=e.has(g),A=!_&&!P):(_=!0,P=!0);const d=A||_,h=A||P;let S=!1;d&&(S=p(y,m,A));let B=!1;h&&(B=p(x,m,A));const C=S||B;if(C)for(let E=0;E<3;E++){const U=y+E,D=x+E,L=c[U],X=c[U+3],lt=c[D],yt=c[D+3];c[u+E]=L<lt?L:lt,c[u+E+3]=X>yt?X:yt}return C}}}function ps(n,e,t,i,s){V.setBuffer(n._roots[e]),Re(0,n,t,i,s),V.clearBuffer()}function Re(n,e,t,i,s){const{float32Array:a,uint16Array:r,uint32Array:o}=V,c=n*2;if(H(c,r)){const l=G(n,o),p=K(c,r);Qi(e,t,i,l,p,s)}else{const l=Z(n);ht(l,a,i)&&Re(l,e,t,i,s);const p=J(n,o);ht(p,a,i)&&Re(p,e,t,i,s)}}const ds=["x","y","z"];function ms(n,e,t,i){V.setBuffer(n._roots[e]);const s=je(0,n,t,i);return V.clearBuffer(),s}function je(n,e,t,i){const{float32Array:s,uint16Array:a,uint32Array:r}=V;let o=n*2;if(H(o,a)){const f=G(n,r),l=K(o,a);return ts(e,t,i,f,l)}else{const f=kn(n,r),l=ds[f],u=i.direction[l]>=0;let m,b;u?(m=Z(n),b=J(n,r)):(m=J(n,r),b=Z(n));const w=ht(m,s,i)?je(m,e,t,i):null;if(w){const v=w.point[l];if(u?v<=s[b+f]:v>=s[b+f+3])return w}const x=ht(b,s,i)?je(b,e,t,i):null;return w&&x?w.distance<=x.distance?w:x:w||x||null}}const se=new rt,_t=new it,Tt=new it,Vt=new mt,hn=new $,re=new $;function hs(n,e,t,i){V.setBuffer(n._roots[e]);const s=Fe(0,n,t,i);return V.clearBuffer(),s}function Fe(n,e,t,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:o}=V;let c=n*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),hn.set(t.boundingBox.min,t.boundingBox.max,i),s=hn),H(c,r)){const l=e.geometry,p=l.index,u=l.attributes.position,m=t.index,b=t.attributes.position,T=G(n,o),w=K(c,r);if(Vt.copy(i).invert(),t.boundsTree)return R(n,a,re),re.matrix.copy(Vt),re.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>re.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(i),x.b.applyMatrix4(i),x.c.applyMatrix4(i),x.needsUpdate=!0;for(let v=T,g=w+T;v<g;v++)if(I(Tt,3*e.resolveTriangleIndex(v),p,u),Tt.needsUpdate=!0,x.intersectsTriangle(Tt))return!0;return!1}});for(let y=T,x=w+T;y<x;y++){const v=e.resolveTriangleIndex(y);I(_t,3*v,p,u),_t.a.applyMatrix4(Vt),_t.b.applyMatrix4(Vt),_t.c.applyMatrix4(Vt),_t.needsUpdate=!0;for(let g=0,A=m.count;g<A;g+=3)if(I(Tt,g,m,b),Tt.needsUpdate=!0,_t.intersectsTriangle(Tt))return!0}}else{const l=n+8,p=o[n+6];return R(l,a,se),!!(s.intersectsBox(se)&&Fe(l,e,t,i,s)||(R(p,a,se),s.intersectsBox(se)&&Fe(p,e,t,i,s)))}}const oe=new mt,Pe=new $,Rt=new $,ys=new k,gs=new k,xs=new k,vs=new k;function bs(n,e,t,i={},s={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),Pe.set(e.boundingBox.min,e.boundingBox.max,t),Pe.needsUpdate=!0;const o=n.geometry,c=o.attributes.position,f=o.index,l=e.attributes.position,p=e.index,u=Y.getPrimitive(),m=Y.getPrimitive();let b=ys,T=gs,w=null,y=null;s&&(w=xs,y=vs);let x=1/0,v=null,g=null;return oe.copy(t).invert(),Rt.matrix.copy(oe),n.shapecast({boundsTraverseOrder:A=>Pe.distanceToBox(A),intersectsBounds:(A,_,P)=>P<x&&P<r?(_&&(Rt.min.copy(A.min),Rt.max.copy(A.max),Rt.needsUpdate=!0),!0):!1,intersectsRange:(A,_)=>{if(e.boundsTree){const P=e.boundsTree;return P.shapecast({boundsTraverseOrder:d=>Rt.distanceToBox(d),intersectsBounds:(d,h,S)=>S<x&&S<r,intersectsRange:(d,h)=>{for(let S=d,B=d+h;S<B;S++){const C=P.resolveTriangleIndex(S);I(m,3*C,p,l),m.a.applyMatrix4(t),m.b.applyMatrix4(t),m.c.applyMatrix4(t),m.needsUpdate=!0;for(let E=A,U=A+_;E<U;E++){const D=n.resolveTriangleIndex(E);I(u,3*D,f,c),u.needsUpdate=!0;const L=u.distanceToTriangle(m,b,w);if(L<x&&(T.copy(b),y&&y.copy(w),x=L,v=E,g=S),L<a)return!0}}}})}else{const P=Nt(e);for(let d=0,h=P;d<h;d++){I(m,3*d,p,l),m.a.applyMatrix4(t),m.b.applyMatrix4(t),m.c.applyMatrix4(t),m.needsUpdate=!0;for(let S=A,B=A+_;S<B;S++){const C=n.resolveTriangleIndex(S);I(u,3*C,f,c),u.needsUpdate=!0;const E=u.distanceToTriangle(m,b,w);if(E<x&&(T.copy(b),y&&y.copy(w),x=E,v=S,g=d),E<a)return!0}}}}}),Y.releasePrimitive(u),Y.releasePrimitive(m),x===1/0?null:(i.point?i.point.copy(T):i.point=T.clone(),i.distance=x,i.faceIndex=v,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(oe),T.applyMatrix4(oe),s.distance=T.sub(s.point).length(),s.faceIndex=g),i)}function ws(){return typeof SharedArrayBuffer<"u"}const Wt=new V.constructor,pe=new V.constructor,ft=new He(()=>new rt),Ct=new rt,Bt=new rt,_e=new rt,Te=new rt;let Ce=!1;function As(n,e,t,i){if(Ce)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ce=!0;const s=n._roots,a=e._roots;let r,o=0,c=0;const f=new mt().copy(t).invert();for(let l=0,p=s.length;l<p;l++){Wt.setBuffer(s[l]),c=0;const u=ft.getPrimitive();R(0,Wt.float32Array,u),u.applyMatrix4(f);for(let m=0,b=a.length;m<b&&(pe.setBuffer(a[l]),r=tt(0,0,t,f,i,o,c,0,0,u),pe.clearBuffer(),c+=a[m].length,!r);m++);if(ft.releasePrimitive(u),Wt.clearBuffer(),o+=s[l].length,r)break}return Ce=!1,r}function tt(n,e,t,i,s,a=0,r=0,o=0,c=0,f=null,l=!1){let p,u;l?(p=pe,u=Wt):(p=Wt,u=pe);const m=p.float32Array,b=p.uint32Array,T=p.uint16Array,w=u.float32Array,y=u.uint32Array,x=u.uint16Array,v=n*2,g=e*2,A=H(v,T),_=H(g,x);let P=!1;if(_&&A)l?P=s(G(e,y),K(e*2,x),G(n,b),K(n*2,T),c,r+e,o,a+n):P=s(G(n,b),K(n*2,T),G(e,y),K(e*2,x),o,a+n,c,r+e);else if(_){const d=ft.getPrimitive();R(e,w,d),d.applyMatrix4(t);const h=Z(n),S=J(n,b);R(h,m,Ct),R(S,m,Bt);const B=d.intersectsBox(Ct),C=d.intersectsBox(Bt);P=B&&tt(e,h,i,t,s,r,a,c,o+1,d,!l)||C&&tt(e,S,i,t,s,r,a,c,o+1,d,!l),ft.releasePrimitive(d)}else{const d=Z(e),h=J(e,y);R(d,w,_e),R(h,w,Te);const S=f.intersectsBox(_e),B=f.intersectsBox(Te);if(S&&B)P=tt(n,d,t,i,s,a,r,o,c+1,f,l)||tt(n,h,t,i,s,a,r,o,c+1,f,l);else if(S)if(A)P=tt(n,d,t,i,s,a,r,o,c+1,f,l);else{const C=ft.getPrimitive();C.copy(_e).applyMatrix4(t);const E=Z(n),U=J(n,b);R(E,m,Ct),R(U,m,Bt);const D=C.intersectsBox(Ct),L=C.intersectsBox(Bt);P=D&&tt(d,E,i,t,s,r,a,c,o+1,C,!l)||L&&tt(d,U,i,t,s,r,a,c,o+1,C,!l),ft.releasePrimitive(C)}else if(B)if(A)P=tt(n,h,t,i,s,a,r,o,c+1,f,l);else{const C=ft.getPrimitive();C.copy(Te).applyMatrix4(t);const E=Z(n),U=J(n,b);R(E,m,Ct),R(U,m,Bt);const D=C.intersectsBox(Ct),L=C.intersectsBox(Bt);P=D&&tt(h,E,i,t,s,r,a,c,o+1,C,!l)||L&&tt(h,U,i,t,s,r,a,c,o+1,C,!l),ft.releasePrimitive(C)}}return P}const ce=new $,yn=new rt,Ss={strategy:En,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class We{static serialize(e,t={}){t={cloneBuffers:!0,...t};const i=e.geometry,s=e._roots,a=e._indirectBuffer,r=i.getIndex();let o;return t.cloneBuffers?o={roots:s.map(c=>c.slice()),index:r?r.array.slice():null,indirectBuffer:a?a.slice():null}:o={roots:s,index:r?r.array:null,indirectBuffer:a},o}static deserialize(e,t,i={}){i={setIndex:!0,indirect:!!e.indirectBuffer,...i};const{index:s,roots:a,indirectBuffer:r}=e,o=new We(t,{...i,[xe]:!0});if(o._roots=a,o._indirectBuffer=r||null,i.setIndex){const c=t.getIndex();if(c===null){const f=new Sn(e.index,1,!1);t.setIndex(f)}else c.array!==s&&(c.array.set(s),c.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Ss,[xe]:!1},t),t.useSharedArrayBuffer&&!ws())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[xe]||(Ri(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new rt)));const{_indirectBuffer:i}=this;this.resolveTriangleIndex=t.indirect?s=>i[s]:s=>s}refit(e=null){return(this.indirect?fs:Yi)(this,e)}traverse(e,t=0){const i=this._roots[t],s=new Uint32Array(i),a=new Uint16Array(i);r(0);function r(o,c=0){const f=o*2,l=a[f+15]===he;if(l){const p=s[o+6],u=a[f+14];e(c,l,new Float32Array(i,o*4,6),p,u)}else{const p=o+Ht/4,u=s[o+6],m=s[o+7];e(c,l,new Float32Array(i,o*4,6),m)||(r(p,c+1),r(u,c+1))}}}raycast(e,t=nn){const i=this._roots,s=this.geometry,a=[],r=t.isMaterial,o=Array.isArray(t),c=s.groups,f=r?t.side:t,l=this.indirect?ps:ns;for(let p=0,u=i.length;p<u;p++){const m=o?t[c[p].materialIndex].side:f,b=a.length;if(l(this,p,m,e,a),o){const T=c[p].materialIndex;for(let w=b,y=a.length;w<y;w++)a[w].face.materialIndex=T}}return a}raycastFirst(e,t=nn){const i=this._roots,s=this.geometry,a=t.isMaterial,r=Array.isArray(t);let o=null;const c=s.groups,f=a?t.side:t,l=this.indirect?ms:ss;for(let p=0,u=i.length;p<u;p++){const m=r?t[c[p].materialIndex].side:f,b=l(this,p,m,e);b!=null&&(o==null||b.distance<o.distance)&&(o=b,r&&(b.face.materialIndex=c[p].materialIndex))}return o}intersectsGeometry(e,t){let i=!1;const s=this._roots,a=this.indirect?hs:rs;for(let r=0,o=s.length;r<o&&(i=a(this,r,e,t),!i);r++);return i}shapecast(e){const t=Y.getPrimitive(),i=this.indirect?es:Ji;let{boundsTraverseOrder:s,intersectsBounds:a,intersectsRange:r,intersectsTriangle:o}=e;if(r&&o){const p=r;r=(u,m,b,T,w)=>p(u,m,b,T,w)?!0:i(u,m,this,o,b,T,t)}else r||(o?r=(p,u,m,b)=>i(p,u,this,o,m,b,t):r=(p,u,m)=>m);let c=!1,f=0;const l=this._roots;for(let p=0,u=l.length;p<u;p++){const m=l[p];if(c=Hi(this,p,a,r,s,f),c)break;f+=m.byteLength}return Y.releasePrimitive(t),c}bvhcast(e,t,i){let{intersectsRanges:s,intersectsTriangles:a}=i;const r=Y.getPrimitive(),o=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?b=>{const T=this.resolveTriangleIndex(b);I(r,T*3,o,c)}:b=>{I(r,b*3,o,c)},l=Y.getPrimitive(),p=e.geometry.index,u=e.geometry.attributes.position,m=e.indirect?b=>{const T=e.resolveTriangleIndex(b);I(l,T*3,p,u)}:b=>{I(l,b*3,p,u)};if(a){const b=(T,w,y,x,v,g,A,_)=>{for(let P=y,d=y+x;P<d;P++){m(P),l.a.applyMatrix4(t),l.b.applyMatrix4(t),l.c.applyMatrix4(t),l.needsUpdate=!0;for(let h=T,S=T+w;h<S;h++)if(f(h),r.needsUpdate=!0,a(r,l,h,P,v,g,A,_))return!0}return!1};if(s){const T=s;s=function(w,y,x,v,g,A,_,P){return T(w,y,x,v,g,A,_,P)?!0:b(w,y,x,v,g,A,_,P)}}else s=b}return As(this,e,t,s)}intersectsBox(e,t){return ce.set(e.min,e.max,t),ce.needsUpdate=!0,this.shapecast({intersectsBounds:i=>ce.intersectsBox(i),intersectsTriangle:i=>ce.intersectsTriangle(i)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,i={},s={},a=0,r=1/0){return(this.indirect?bs:us)(this,e,t,i,s,a,r)}closestPointToPoint(e,t={},i=0,s=1/0){return Wi(this,e,t,i,s)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(i=>{R(0,new Float32Array(i),yn),e.union(yn)}),e}}function gn(n,e,t){return n===null||(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n.distance<t.near||n.distance>t.far)?null:n}const Be=new si,xn=new mt,Ps=_n.prototype.raycast;function _s(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;xn.copy(this.matrixWorld).invert(),Be.copy(n.ray).applyMatrix4(xn);const t=this.geometry.boundsTree;if(n.firstHitOnly===!0){const i=gn(t.raycastFirst(Be,this.material),this,n);i&&e.push(i)}else{const i=t.raycast(Be,this.material);for(let s=0,a=i.length;s<a;s++){const r=gn(i[s],this,n);r&&e.push(r)}}}else Ps.call(this,n,e)}function Ts(n){return this.boundsTree=new We(this,n),this.boundsTree}function Cs(){this.boundsTree=null}function Bs({modelInCopy:n}){const e=new It({color:15461355});var t=new ae({color:10921638,linewidth:10});const i=new qe(Tn);return i.uniforms.diffuse.value.set(0),M.useEffect(()=>{const s=[];n.traverse(a=>{if(a.frustumCulled=!0,a.isMesh){a.material=e,a.frustumCulled=!1;var r=new le(a.geometry,20),o=new $t(r,t);s.push(a.geometry);const c=new ri(oi(a.geometry)),f=new $t(c,i);a.add(o),a.add(f),r.dispose(),a.geometry.dispose(),e.dispose()}})},[]),N(Q,{children:N("primitive",{object:n,scale:1})})}et.memo(Bs);new di;const Ms={linewidth:{value:1},resolution:{value:new mi(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1},opacity:{value:1}},Me={uniforms:Mn.merge([rn.common,rn.fog,Ms]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 control0;
		attribute vec3 control1;
		attribute vec3 direction;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

			// conditional logic
			// Transform the line segment ends and control points into camera clip space
			vec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );
			vec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );
			vec4 p0 = projectionMatrix * modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 p1 = projectionMatrix * modelViewMatrix * vec4( instanceStart + direction, 1.0 );

			c0 /= c0.w;
			c1 /= c1.w;
			p0 /= p0.w;
			p1 /= p1.w;

			// Get the direction of the segment and an orthogonal vector
			vec2 segDir = p1.xy - p0.xy;
			vec2 norm = vec2( - segDir.y, segDir.x );

			// Get control point directions from the line
			vec2 c0dir = c0.xy - p1.xy;
			vec2 c1dir = c1.xy - p1.xy;

			// If the vectors to the controls points are pointed in different directions away
			// from the line segment then the line should not be drawn.
			float d0 = dot( normalize( norm ), normalize( c0dir ) );
			float d1 = dot( normalize( norm ), normalize( c1dir ) );
			float discardFlag = float( sign( d0 ) != sign( d1 ) );
			gl_Position = discardFlag > 0.5 ? c0 : gl_Position;
			// end conditional line logic

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class Es extends hi{constructor(e){super({type:"ConditionalLineMaterial",uniforms:Mn.clone(Me.uniforms),vertexShader:Me.vertexShader,fragmentShader:Me.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}}}),this.setValues(e)}}Es.prototype.isConditionalLineMaterial=!0;ci({OutlineEffect:vi});const Ee=[],ze=[];function zs({modelIn:n,modelOut:e,modelInCopy:t,modelInCopy2:i,modelOutCopy:s}){sn.prototype.computeBoundsTree=Ts,sn.prototype.disposeBoundsTree=Cs,_n.prototype.raycast=_s,console.log("render count");const{gl:a,camera:r,scene:o}=ai(),c=M.useRef(),f=M.useRef();M.useRef(),M.useRef(),M.useRef(),a.setPixelRatio(Math.min(window.devicePixelRatio,2));let{stepCount:l,modelProperties:p,partsInOut:u,setVisibleModel:m,setCurrentStepObj:b,currentStepObject:T,selectedParts:w,setProperties:y,setCurrentObject:x,visibleObj:v}=M.useContext(nt);const[g,A]=M.useState(!1),[_,P]=M.useState(!1),[d,h]=M.useState(i);M.useState();const[S,B]=M.useState(t);M.useState(i);const[C,E]=M.useState();M.useState(),M.useState();const[U,D]=M.useState(),[L,X]=M.useState();M.useState();const lt=new It({color:15461355}),yt=new It({color:16777215}),Xe=new It({color:16711680,wireframe:!0}),Ge=new It({color:13754592});var Ke=new ae({color:4210752,linewidth:10}),Ze=new ae({color:6723993,linewidth:50}),jn=new ae({color:10921638,linewidth:10});new qe(Tn).uniforms.diffuse.value.set(0);const Je=["05_Fix_the_shade_on_the_structure"],Xt=[["03_Assemble_the_lamp_shade_-_part_1","04_Assemble_the_lamp_shade_-_part_2"]],Fn=["111_Wiring_1","112_Wiring_2","113_Wiring_3"],Ye=[];let Qe=[],kt=[];M.useEffect(()=>{u===!0?(h(i),X(i.getObjectByName(g[l]))):u===!1&&(h(s),X(s.getObjectByName(g[l])))},[u]),M.useEffect(()=>{d.traverse(z=>{z.isObject3D&&!z.isMesh&&!z.isGroup&&(Ee.push(z.name),ze.push(z.userData.name))},[]),Ee.sort(),A(Ee),ze.sort(),P(ze),S.traverse(z=>{if(z.isMesh){z.material=lt,z.frustumCulled=!1;var q=new le(z.geometry,20),O=new $t(q,jn);z.add(O),z.geometry.dispose(),lt.dispose()}}),b(t.getObjectByName(g[0])),X(d.getObjectByName(g[0])),tn(),pt()},[]);const In=Je.some(z=>z.includes(g[l])),qn=Xt.some(z=>z.includes(g[l]));W(z=>z.wiringStep);const $n=W(z=>z.isWiringStep),Hn=W(z=>z.isNotWiringStep);Fn.some(z=>z.includes(g[l]))?$n():Hn(),M.useEffect(()=>{b(i.getObjectByName(g[l])),X(d.getObjectByName(g[l]))},[g,l]),M.useEffect(()=>{console.log(T),tn()},[g,l,T]),M.useEffect(()=>{L&&(x(L.getObjectByName(g[l])),w!=[]&&Kn(),pt())},[w,L]);const tn=M.useCallback(()=>{let z=[],q=[];const O=[];if(T){for(let xt=0;xt<T.children.length;xt++)T.children[xt].traverse(gt=>{gt.isGroup&&gt.userData.name!=null&&O.push(gt.userData.name),z=[...new Set(O)],q=z.map(st=>[O.filter(Yn=>Yn===st).length,st])});const F=T.userData.name;y({partsNames:q,titleName:F})}}),Wn=M.useCallback(()=>{for(let z=l-1;z>=0;z--)for(let q=kt.length-1;q>=0;q--)if(g[z]===kt[q]){let O=S.getObjectByName(`${g[z]}`,!0);Qe.push(O)}}),Xn=M.useCallback(()=>{for(let O=0;O<Xt.length;O++){kt=Xt[O];for(let F=0;F<kt.length;F++)kt.some(gt=>gt.includes(g[l]))&&Wn()}let z=new fe,q=L.clone();z.add(q),Qe.filter(O=>Xt.some(F=>F.includes(O.name))).forEach(O=>{O.visible=!0;let F=O.clone();z.add(F)}),m(z)}),Gn=M.useCallback(()=>{for(let O=l-1;O>=0;O--){let F=S.getObjectByName(`${g[O]}`,!0);Ye.push(F)}let z=new fe;Ye.filter(O=>!Je.some(F=>F.includes(O.name))).forEach(O=>{O.visible=!0;let F=O.clone();z.add(F)});let q=L.clone();z.add(q),m(z)}),Kn=M.useCallback(()=>{if(L){const z=[];for(let q=0;q<L.children.length;q++)L.children[q].traverse(O=>{if(O.isMesh&&w.includes(L.children[q].userData.name)){O.frustumCulled=!1;const st=O.geometry.clone();z.push(st),O.material=Ge;var F=new le(O.geometry,20),xt=new $t(F,Ze);O.add(xt),Ge.dispose(),F.dispose(),Ze.dispose()}else if(O.isMesh&&L.children[q].userData.name!="Curves"){O.frustumCulled=!1,O.material=yt;var F=new le(O.geometry,20),gt=new $t(F,Ke);O.add(gt),F.dispose(),Ke.dispose()}else if(O.userData.name==="Curves"&&(O.frustumCulled=!1,O.material=Xe,O.isGroup))for(let st=0;st<O.children.length;st++)O.children[st].isMesh&&(O.children[st].frustumCulled=!1,O.children[st].material=Xe)});D(w)}});M.useCallback(()=>{C.traverse(z=>{z.name==="Botom_Panel"&&console.log(C.userData.name)})}),M.useCallback(z=>{z.stopPropagation(),console.log(z.object)});const Zn=M.useCallback(()=>{if(L){L.clone();for(let z=0;z<d.children.length;z++)d.children[z].visible=!1;for(let z=0;z<S.children.length;z++)S.children[z].visible=!1;In?(console.log("exception"),L.visible=!0,m(L)):qn?(console.log("preparing step"),L.visible=!0,Xn()):(console.log("main building step"),L.visible=!0,Gn())}},[L]);M.useEffect(()=>{Zn()},[L]);const{setListOfStep:Jn}=M.useContext(nt);return Jn(_),M.useState(null),N(Q,{children:N(wi,{children:g?j(Q,{children:[N("primitive",{ref:c,object:d,scale:1.0001}),N("primitive",{ref:f,object:S,scale:1})]}):null})})}const Ns=et.memo(zs);function ks(){let n=[],e=new fe;const{modelProperties:t,visibleObj:i,currentStepObject:s,setClickedParts:a,selectedParts:r,partsInOut:o,setCurrentPartsModel:c,currentObject:f,partBtnState:l,setPartButtonState:p}=M.useContext(nt),[u,m]=M.useState(null);M.useState(!1);const[b,T]=M.useState(!1),w=W(g=>g.wiringStep),y=M.useCallback(()=>{if(e=new fe,n=[],u){console.log(u);for(let g=0;g<f.children.length;g++)if(f.children[g].userData.name===u){const A=f.children[g].clone();e.add(A),n.push(f.children[g].userData.name)}a(n),c(e)}});M.useEffect(()=>{n=[],a(n),y()},[s,u]),M.useEffect(()=>{p(!1),n=[],a(n),c(null)},[s]);const x=()=>{l===!0&&(p(!1),n=[],a(n),c(null)),l===!1&&(p(!0),y())},v=()=>{console.log("disable"),p(!1),n=[],a(n),c(null),m(null)};return N(Q,{children:N("div",{children:N("ul",{children:t?t.partsNames.map(([g,A],_)=>N("li",{children:A===u?j("button",{id:`${A}`,style:{backgroundColor:"#669999",color:"#ffffff"},disabled:b,onClick:()=>{l===!0&&v()},className:"parts",children:[j("b",{children:[" ",g,"x"]}),"  ",A]}):w?j("p",{style:{paddingBottom:10},children:[j("b",{children:[" ",g,"x"]}),"  ",A]}):j("button",{id:`${A}`,disabled:b,onClick:()=>{m(A),x()},className:"parts",children:[j("b",{children:[" ",g,"x "]}),"  ",A]})},_)):null})})})}function Us(){const{modelProperties:n}=M.useContext(nt);return N(Q,{children:N("div",{children:n?n.titleName:null})})}function Os(){const{stepList:n,setStepPosition:e,stepCount:t,currentStepName:i,modelProperties:s}=M.useContext(nt);M.useState("stepNaviBtn");const[a,r]=M.useState();return n&&[...Array(n.length)],N("div",{children:N("ul",{children:n?n.map((o,c)=>N("li",{children:s&&o===s.titleName?N("button",{id:`${o}`,style:{backgroundColor:"#000000",color:"#ffffff"},onClick:()=>{e(c)},className:"stepNaviBtn",children:o}):N("button",{id:`${o}`,style:{backgroundColor:a},onClick:()=>{e(c)},className:"stepNaviBtn",children:o})},c)):null})})}const Ls=et.memo(Os);function Ds({cameraControlsRef:n}){let{visibleObj:e,modelProperties:t,selectedPartsModel:i,selectedParts:s,currentObject:a,setCamera:r,partBtnState:o,currentStepObject:c}=M.useContext(nt);const f=Cn(),l=W(p=>p.cameraPositionTag);M.useEffect(()=>{e?(f.refresh(e).fit().clip(),pt()):(f.refresh(c).fit().clip(),pt())},[c,l]),M.useEffect(()=>{i?(f.refresh(i).fit(),pt()):i||(f.refresh(e).fit(),pt())},[i])}var Ln={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},vn=et.createContext&&et.createContext(Ln),Vs=["attr","size","title"];function Rs(n,e){if(n==null)return{};var t=js(n,e),i,s;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(s=0;s<a.length;s++)i=a[s],!(e.indexOf(i)>=0)&&Object.prototype.propertyIsEnumerable.call(n,i)&&(t[i]=n[i])}return t}function js(n,e){if(n==null)return{};var t={},i=Object.keys(n),s,a;for(a=0;a<i.length;a++)s=i[a],!(e.indexOf(s)>=0)&&(t[s]=n[s]);return t}function de(){return de=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},de.apply(this,arguments)}function bn(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),t.push.apply(t,i)}return t}function me(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?bn(Object(t),!0).forEach(function(i){Fs(n,i,t[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):bn(Object(t)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(t,i))})}return n}function Fs(n,e,t){return e=Is(e),e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function Is(n){var e=qs(n,"string");return typeof e=="symbol"?e:String(e)}function qs(n,e){if(typeof n!="object"||n===null)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var i=t.call(n,e||"default");if(typeof i!="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function Dn(n){return n&&n.map((e,t)=>et.createElement(e.tag,me({key:t},e.attr),Dn(e.child)))}function Vn(n){return e=>et.createElement($s,de({attr:me({},n.attr)},e),Dn(n.child))}function $s(n){var e=t=>{var{attr:i,size:s,title:a}=n,r=Rs(n,Vs),o=s||t.size||"1em",c;return t.className&&(c=t.className),n.className&&(c=(c?c+" ":"")+n.className),et.createElement("svg",de({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,i,r,{className:c,style:me(me({color:n.color||t.color},t.style),n.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),a&&et.createElement("title",null,a),n.children)};return vn!==void 0?et.createElement(vn.Consumer,null,t=>e(t)):e(Ln)}function Hs(n){return Vn({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"circle",attr:{cx:"12",cy:"12",r:"10"},child:[]},{tag:"line",attr:{x1:"12",x2:"12",y1:"8",y2:"12"},child:[]},{tag:"line",attr:{x1:"12",x2:"12.01",y1:"16",y2:"16"},child:[]}]})(n)}let Ie=1,Rn=new Array;new Array;let Ne=new Array,jt;Bn.get("https://sheets.googleapis.com/v4/spreadsheets/11ayVTVvDEbOezJJSL6N2_ct-rm7NgKWlpBPqqtvVh5U/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(n=>{let e=n.data.values,t=new Array;for(const i of e)Ie>2&&i[1]!=""&&(Rn.push(t),t=new Array),t.push(i),++Ie});function Ws(){let{stepCount:n}=M.useContext(nt);const e=W(s=>s.isVisible);M.useState();const t=W(s=>s.isNotVisibleToggle),i=W(s=>s.isVisibleToggle);return M.useEffect(()=>{jt=new Array;for(const s of Rn[n+1])s[10]!=""&&s[10]!=null&&(Ne=new Array,Ne.push(s[10]),jt.push(Ne)),++Ie},[n]),M.useEffect(()=>{jt.length===0?t():i()},[n]),N(Q,{children:jt?j("div",{children:[j("div",{id:"RemarksTitle",style:{margin:"auto",display:"inline",alignContent:"baseline",visibility:`${e}`},children:[j("h3",{children:[" ",N(Hs,{})," Remarks"]})," ",N("br",{})]}),N("ul",{children:jt.map((s,a)=>j("li",{children:[" ",s]},a))})]}):null})}function Xs(n){return Vn({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"},child:[]},{tag:"path",attr:{d:"m18.25 7.6-5.5-3.18a1.49 1.49 0 0 0-1.5 0L5.75 7.6c-.46.27-.75.76-.75 1.3v6.35c0 .54.29 1.03.75 1.3l5.5 3.18c.46.27 1.04.27 1.5 0l5.5-3.18c.46-.27.75-.76.75-1.3V8.9c0-.54-.29-1.03-.75-1.3zM7 14.96v-4.62l4 2.32v4.61l-4-2.31zm5-4.03L8 8.61l4-2.31 4 2.31-4 2.32zm1 6.34v-4.61l4-2.32v4.62l-4 2.31zM7 2H3.5C2.67 2 2 2.67 2 3.5V7h2V4h3V2zm10 0h3.5c.83 0 1.5.67 1.5 1.5V7h-2V4h-3V2zM7 22H3.5c-.83 0-1.5-.67-1.5-1.5V17h2v3h3v2zm10 0h3.5c.83 0 1.5-.67 1.5-1.5V17h-2v3h-3v2z"},child:[]}]})(n)}let wn=1,Gs=new Array;new Array;Bn.get("https://sheets.googleapis.com/v4/spreadsheets/11ayVTVvDEbOezJJSL6N2_ct-rm7NgKWlpBPqqtvVh5U/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(n=>{let e=n.data.values,t=new Array;for(const i of e)wn>2&&i[1]!=""&&(Gs.push(t),t=new Array),t.push(i),++wn});function Ks(){let{visibleObj:n,selectedParts:e,stepSVG:t}=M.useContext(nt);const i=W(l=>l.cameraPositionTag),s=W(l=>l.freeControls),a=W(l=>l.wiringStep),r=Cn(),[o]=M.useState(()=>new k),[c]=M.useState(()=>new k),f=new k(4,1,8);return li((l,p)=>{i==="initial"&&a===!1&&(o.lerp(f,.1),c.lerp([0,0,0],.1),l.camera.position.copy(o),l.camera.lookAt(c),s(),r.refresh(n).fit(),pt()),i==="initial"&&a===!0&&(console.log(t),t.reset(),s(),pt())}),N(Q,{})}function er(){const n=Mt("./Tchibo_IN.glb"),e=Mt("./Tchibo_OUT.glb"),t=M.useMemo(()=>n.scene.clone(),[n]),i=M.useMemo(()=>n.scene.clone(),[n]),s=M.useMemo(()=>e.scene.clone(),[e]);M.useState(!1),M.useRef(),M.useRef(),Mt.clear("./Tchibo_IN.glb"),Mt.clear("./Tchibo_OUT.glb");const a=W(r=>r.resetCamera);return N(Q,{children:j(M.Fragment,{children:[N("aside",{className:"stepNavi",children:N(Ls,{})}),j("section",{id:"currentStepArea",children:[j("nav",{className:"currentStepBar",children:[N("h2",{id:"stepTitleArea",children:N(Us,{})}),j("div",{id:"stepControl",children:[N(gi,{}),"                        "]})]}),j("div",{className:"infoColumn",children:[N("div",{className:"stepPartsArea",children:N(ks,{})}),N("div",{className:"stepRemarksArea",children:N(Ws,{})})]}),j("article",{className:"viewArea",id:"viewArea",children:[N(M.Suspense,{fallback:null,children:j(ui,{linear:!0,flat:!0,frameloop:"demand",camera:{fov:45,near:1,far:10,position:[4,1,8]},children:[N(Zs,{}),N("color",{args:["#f5f5f5"],attach:"background"}),N(fi,{clip:!0,observe:!0,damping:2,margin:.85,children:j(M.Suspense,{fallback:null,children:[N(Ns,{modelIn:n,modelOut:e,modelInCopy:t,modelInCopy2:i,modelOutCopy:s}),N(Ds,{})]})}),N(Ks,{})]})}),N(yi,{}),j("button",{className:"btn",style:{position:"absolute",bottom:"20px",left:"20px"},onClick:a,children:[N(Xs,{})," Reset Camera"]}),N(xi,{})]})]})]})})}Mt.preload("./Tchibo_IN.glb");Mt.preload("./Tchibo_OUT.glb");function Zs(){const n=M.useRef();return N(Q,{children:N(pi,{ref:n,makeDefault:!0,enableDamping:!1,enableRotate:!0,minAzimuthAngle:1/0,maxAzimuthAngle:1/0,minPolarAngle:0,maxPolarAngle:1/0})})}export{er as default};
//# sourceMappingURL=App-aaefc412.js.map
