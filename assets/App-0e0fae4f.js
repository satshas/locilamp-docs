import{r as B,u as W,M as nt,s as ai,j as z,F as H,a as D,C as li,S as Ke,U as ui,b as on,B as En,R as et,c as zn,V as L,d as Et,P as Nn,L as lt,T as It,e as fi,f as mt,g as ot,D as di,h as cn,i as kn,k as pi,l as $t,m as le,n as Ln,E as ue,o as Ht,p as mi,q as hi,t as yi,v as an,w as gi,x as zt,G as de,y as Un,z as Rn,A as vi,H as xi,I as Bt,J as bi,K as wi,O as Ai}from"./index-a1ed98fa.js";import{Vector3 as Si,Vector2 as Pi,UniformsUtils as On,UniformsLib as ln,ShaderMaterial as Ti}from"//cdn.skypack.dev/three@0.130.1/build/three.module.js";import"//cdn.skypack.dev/three@0.130.1/examples/jsm/lines/LineSegmentsGeometry.js";function Ci(){const t=B.useRef(),n=W(s=>s.wiringStep);let{currentStepObject:e,setCurrentSVG:i}=B.useContext(nt);return B.useEffect(()=>{n&&document.getElementById("myEmbed").addEventListener("load",function(){i(ai(document.getElementById("myEmbed")))})},[n]),z(H,{children:n?z("div",{id:"svgContainer",style:{position:"absolute",width:"100%",height:"100%",bottom:"0px",left:"0px",padding:"10px"},children:z("embed",{style:{width:"100%",height:"100%",backgroundColor:"#e9e9e9"},ref:t,type:"image/svg+xml",src:`./${e.name}.svg`,id:"myEmbed"})}):null})}function _i(){let{setStepPosition:t,stepCount:n,stepList:e}=B.useContext(nt);const i=()=>{n++,t(n)},s=()=>{n--,t(n)};return D(H,{children:[n>=1?z("button",{onClick:s,className:"btn",id:"nextStep",children:" ❮ Previous Step  "}):null,e&&n+1<=e.length-1?z("button",{onClick:i,className:"btn",id:"nextStep",children:"Next Step ❯ "}):null]})}function Bi(){const{setModelInOut:t,selectedParts:n}=B.useContext(nt),[e,i]=B.useState(!1),s=W(r=>r.wiringStep);return z(H,{children:s?null:z("button",{onClick:()=>{e==!1?(document.getElementById("partsOut").innerHTML="Assemble",i(!0),t(e)):e==!0&&(document.getElementById("partsOut").innerHTML="Explode",i(!1),t(e))},className:"btn",id:"partsOut",children:"Explode"})})}class Mi{constructor(n,e={}){this.enabled=!0;const i=e.defaultThickness!==void 0?e.defaultThickness:.003,s=new li().fromArray(e.defaultColor!==void 0?e.defaultColor:[0,0,0]),a=e.defaultAlpha!==void 0?e.defaultAlpha:1,r=e.defaultKeepAlive!==void 0?e.defaultKeepAlive:!1,o={},c=60,f={},l={},d={outlineThickness:{value:i},outlineColor:{value:s},outlineAlpha:{value:a}},u=["#include <common>","#include <uv_pars_vertex>","#include <displacementmap_pars_vertex>","#include <fog_pars_vertex>","#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","uniform float outlineThickness;","vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {","	float thickness = outlineThickness;","	const float ratio = 1.0;","	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );","	vec4 norm = normalize( pos - pos2 );","	return pos + norm * thickness * pos.w * ratio;","}","void main() {","	#include <uv_vertex>","	#include <beginnormal_vertex>","	#include <morphnormal_vertex>","	#include <skinbase_vertex>","	#include <skinnormal_vertex>","	#include <begin_vertex>","	#include <morphtarget_vertex>","	#include <skinning_vertex>","	#include <displacementmap_vertex>","	#include <project_vertex>","	vec3 outlineNormal = - objectNormal;","	gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );","	#include <logdepthbuf_vertex>","	#include <clipping_planes_vertex>","	#include <fog_vertex>","}"].join(`
`),h=["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","#include <clipping_planes_pars_fragment>","uniform vec3 outlineColor;","uniform float outlineAlpha;","void main() {","	#include <clipping_planes_fragment>","	#include <logdepthbuf_fragment>","	gl_FragColor = vec4( outlineColor, outlineAlpha );","	#include <tonemapping_fragment>","	#include <encodings_fragment>","	#include <fog_fragment>","	#include <premultiplied_alpha_fragment>","}"].join(`
`);function w(){return new Ke({type:"OutlineEffect",uniforms:ui.merge([on.fog,on.displacementmap,d]),vertexShader:u,fragmentShader:h,side:En})}function _(p){let m=o[p.uuid];return m===void 0&&(m={material:w(),used:!0,keepAlive:r,count:0},o[p.uuid]=m),m.used=!0,m.material}function A(p){const m=_(p);return f[m.uuid]=p,T(m,p),m}function y(p){const m=p.geometry;let b=!1;return p.geometry!==void 0&&(m.isBufferGeometry?b=m.attributes.normal!==void 0:b=!0),p.isMesh===!0&&p.material!==void 0&&b===!0}function v(p){if(y(p)!==!1){if(Array.isArray(p.material))for(let m=0,b=p.material.length;m<b;m++)p.material[m]=A(p.material[m]);else p.material=A(p.material);l[p.uuid]=p.onBeforeRender,p.onBeforeRender=x}}function g(p){if(y(p)!==!1){if(Array.isArray(p.material))for(let m=0,b=p.material.length;m<b;m++)p.material[m]=f[p.material[m].uuid];else p.material=f[p.material.uuid];p.onBeforeRender=l[p.uuid]}}function x(p,m,b,M,C){const E=f[C.uuid];E!==void 0&&S(C,E)}function S(p,m){const b=m.userData.outlineParameters;p.uniforms.outlineAlpha.value=m.opacity,b!==void 0&&(b.thickness!==void 0&&(p.uniforms.outlineThickness.value=b.thickness),b.color!==void 0&&p.uniforms.outlineColor.value.fromArray(b.color),b.alpha!==void 0&&(p.uniforms.outlineAlpha.value=b.alpha)),m.displacementMap&&(p.uniforms.displacementMap.value=m.displacementMap,p.uniforms.displacementScale.value=m.displacementScale,p.uniforms.displacementBias.value=m.displacementBias)}function T(p,m){if(p.name==="invisible")return;const b=m.userData.outlineParameters;p.fog=m.fog,p.toneMapped=m.toneMapped,p.premultipliedAlpha=m.premultipliedAlpha,p.displacementMap=m.displacementMap,b!==void 0?(m.visible===!1?p.visible=!1:p.visible=b.visible!==void 0?b.visible:!0,p.transparent=b.alpha!==void 0&&b.alpha<1?!0:m.transparent,b.keepAlive!==void 0&&(o[m.uuid].keepAlive=b.keepAlive)):(p.transparent=m.transparent,p.visible=m.visible),(m.wireframe===!0||m.depthTest===!1)&&(p.visible=!1),m.clippingPlanes&&(p.clipping=!0,p.clippingPlanes=m.clippingPlanes,p.clipIntersection=m.clipIntersection,p.clipShadows=m.clipShadows),p.version=m.version}function P(){let p;p=Object.keys(f);for(let m=0,b=p.length;m<b;m++)f[p[m]]=void 0;p=Object.keys(l);for(let m=0,b=p.length;m<b;m++)l[p[m]]=void 0;p=Object.keys(o);for(let m=0,b=p.length;m<b;m++){const M=p[m];o[M].used===!1?(o[M].count++,o[M].keepAlive===!1&&o[M].count>c&&delete o[M]):(o[M].used=!1,o[M].count=0)}}this.render=function(p,m){if(this.enabled===!1){n.render(p,m);return}const b=n.autoClear;n.autoClear=this.autoClear,n.render(p,m),n.autoClear=b,this.renderOutline(p,m)},this.renderOutline=function(p,m){const b=n.autoClear,M=p.matrixWorldAutoUpdate,C=p.background,E=n.shadowMap.enabled;p.matrixWorldAutoUpdate=!1,p.background=null,n.autoClear=!1,n.shadowMap.enabled=!1,p.traverse(v),n.render(p,m),p.traverse(g),P(),p.matrixWorldAutoUpdate=M,p.background=C,n.autoClear=b,n.shadowMap.enabled=E},this.autoClear=n.autoClear,this.domElement=n.domElement,this.shadowMap=n.shadowMap,this.clear=function(p,m,b){n.clear(p,m,b)},this.getPixelRatio=function(){return n.getPixelRatio()},this.setPixelRatio=function(p){n.setPixelRatio(p)},this.getSize=function(p){return n.getSize(p)},this.setSize=function(p,m,b){n.setSize(p,m,b)},this.setViewport=function(p,m,b,M){n.setViewport(p,m,b,M)},this.setScissor=function(p,m,b,M){n.setScissor(p,m,b,M)},this.setScissorTest=function(p){n.setScissorTest(p)},this.setRenderTarget=function(p){n.setRenderTarget(p)}}}const Ei=B.createContext(null);function zi(t){let{children:n,enabled:e=!0}=t;const[i,s]=B.useState([]),a=B.useMemo(()=>({selected:i,select:s,enabled:e}),[i,s,e]);return et.createElement(Ei.Provider,{value:a},n)}const Vn=0,Ni=1,ki=2,un=2,xe=1.25,fn=1,Wt=6*4+4+4,ge=65535,Li=Math.pow(2,-24),be=Symbol("SKIP_GENERATION");function Ui(t){return t.index?t.index.count:t.attributes.position.count}function Nt(t){return Ui(t)/3}function Ri(t,n=ArrayBuffer){return t>65535?new Uint32Array(new n(4*t)):new Uint16Array(new n(2*t))}function Oi(t,n){if(!t.index){const e=t.attributes.position.count,i=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Ri(e,i);t.setIndex(new zn(s,1));for(let a=0;a<e;a++)s[a]=a}}function Dn(t){const n=Nt(t),e=t.drawRange,i=e.start/3,s=(e.start+e.count)/3,a=Math.max(0,i),r=Math.min(n,s)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function Fn(t){if(!t.groups||!t.groups.length)return Dn(t);const n=[],e=new Set,i=t.drawRange,s=i.start/3,a=(i.start+i.count)/3;for(const o of t.groups){const c=o.start/3,f=(o.start+o.count)/3;e.add(Math.max(s,c)),e.add(Math.min(a,f))}const r=Array.from(e.values()).sort((o,c)=>o-c);for(let o=0;o<r.length-1;o++){const c=r[o],f=r[o+1];n.push({offset:Math.floor(c),count:Math.floor(f-c)})}return n}function Vi(t){if(t.groups.length===0)return!1;const n=Nt(t),e=Fn(t).sort((a,r)=>a.offset-r.offset),i=e[e.length-1];i.count=Math.min(n-i.offset,i.count);let s=0;return e.forEach(({count:a})=>s+=a),n!==s}function we(t,n,e,i,s){let a=1/0,r=1/0,o=1/0,c=-1/0,f=-1/0,l=-1/0,d=1/0,u=1/0,h=1/0,w=-1/0,_=-1/0,A=-1/0;for(let y=n*6,v=(n+e)*6;y<v;y+=6){const g=t[y+0],x=t[y+1],S=g-x,T=g+x;S<a&&(a=S),T>c&&(c=T),g<d&&(d=g),g>w&&(w=g);const P=t[y+2],p=t[y+3],m=P-p,b=P+p;m<r&&(r=m),b>f&&(f=b),P<u&&(u=P),P>_&&(_=P);const M=t[y+4],C=t[y+5],E=M-C,k=M+C;E<o&&(o=E),k>l&&(l=k),M<h&&(h=M),M>A&&(A=M)}i[0]=a,i[1]=r,i[2]=o,i[3]=c,i[4]=f,i[5]=l,s[0]=d,s[1]=u,s[2]=h,s[3]=w,s[4]=_,s[5]=A}function Di(t,n=null,e=null,i=null){const s=t.attributes.position,a=t.index?t.index.array:null,r=Nt(t),o=s.normalized;let c;n===null?(c=new Float32Array(r*6*4),e=0,i=r):(c=n,e=e||0,i=i||r);const f=s.array,l=s.offset||0;let d=3;s.isInterleavedBufferAttribute&&(d=s.data.stride);const u=["getX","getY","getZ"];for(let h=e;h<e+i;h++){const w=h*3,_=h*6;let A=w+0,y=w+1,v=w+2;a&&(A=a[A],y=a[y],v=a[v]),o||(A=A*d+l,y=y*d+l,v=v*d+l);for(let g=0;g<3;g++){let x,S,T;o?(x=s[u[g]](A),S=s[u[g]](y),T=s[u[g]](v)):(x=f[A+g],S=f[y+g],T=f[v+g]);let P=x;S<P&&(P=S),T<P&&(P=T);let p=x;S>p&&(p=S),T>p&&(p=T);const m=(p-P)/2,b=g*2;c[_+b+0]=P+m,c[_+b+1]=m+(Math.abs(P)+m)*Li}}return c}function F(t,n,e){return e.min.x=n[t],e.min.y=n[t+1],e.min.z=n[t+2],e.max.x=n[t+3],e.max.y=n[t+4],e.max.z=n[t+5],e}function dn(t){let n=-1,e=-1/0;for(let i=0;i<3;i++){const s=t[i+3]-t[i];s>e&&(e=s,n=i)}return n}function pn(t,n){n.set(t)}function mn(t,n,e){let i,s;for(let a=0;a<3;a++){const r=a+3;i=t[a],s=n[a],e[a]=i<s?i:s,i=t[r],s=n[r],e[r]=i>s?i:s}}function Gt(t,n,e){for(let i=0;i<3;i++){const s=n[t+2*i],a=n[t+2*i+1],r=s-a,o=s+a;r<e[i]&&(e[i]=r),o>e[i+3]&&(e[i+3]=o)}}function Ut(t){const n=t[3]-t[0],e=t[4]-t[1],i=t[5]-t[2];return 2*(n*e+e*i+i*n)}const at=32,Fi=(t,n)=>t.candidate-n.candidate,ft=new Array(at).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Zt=new Float32Array(6);function ji(t,n,e,i,s,a){let r=-1,o=0;if(a===Vn)r=dn(n),r!==-1&&(o=(n[r]+n[r+3])/2);else if(a===Ni)r=dn(t),r!==-1&&(o=Ii(e,i,s,r));else if(a===ki){const c=Ut(t);let f=xe*s;const l=i*6,d=(i+s)*6;for(let u=0;u<3;u++){const h=n[u],A=(n[u+3]-h)/at;if(s<at/4){const y=[...ft];y.length=s;let v=0;for(let x=l;x<d;x+=6,v++){const S=y[v];S.candidate=e[x+2*u],S.count=0;const{bounds:T,leftCacheBounds:P,rightCacheBounds:p}=S;for(let m=0;m<3;m++)p[m]=1/0,p[m+3]=-1/0,P[m]=1/0,P[m+3]=-1/0,T[m]=1/0,T[m+3]=-1/0;Gt(x,e,T)}y.sort(Fi);let g=s;for(let x=0;x<g;x++){const S=y[x];for(;x+1<g&&y[x+1].candidate===S.candidate;)y.splice(x+1,1),g--}for(let x=l;x<d;x+=6){const S=e[x+2*u];for(let T=0;T<g;T++){const P=y[T];S>=P.candidate?Gt(x,e,P.rightCacheBounds):(Gt(x,e,P.leftCacheBounds),P.count++)}}for(let x=0;x<g;x++){const S=y[x],T=S.count,P=s-S.count,p=S.leftCacheBounds,m=S.rightCacheBounds;let b=0;T!==0&&(b=Ut(p)/c);let M=0;P!==0&&(M=Ut(m)/c);const C=fn+xe*(b*T+M*P);C<f&&(r=u,f=C,o=S.candidate)}}else{for(let g=0;g<at;g++){const x=ft[g];x.count=0,x.candidate=h+A+g*A;const S=x.bounds;for(let T=0;T<3;T++)S[T]=1/0,S[T+3]=-1/0}for(let g=l;g<d;g+=6){let T=~~((e[g+2*u]-h)/A);T>=at&&(T=at-1);const P=ft[T];P.count++,Gt(g,e,P.bounds)}const y=ft[at-1];pn(y.bounds,y.rightCacheBounds);for(let g=at-2;g>=0;g--){const x=ft[g],S=ft[g+1];mn(x.bounds,S.rightCacheBounds,x.rightCacheBounds)}let v=0;for(let g=0;g<at-1;g++){const x=ft[g],S=x.count,T=x.bounds,p=ft[g+1].rightCacheBounds;S!==0&&(v===0?pn(T,Zt):mn(T,Zt,Zt)),v+=S;let m=0,b=0;v!==0&&(m=Ut(Zt)/c);const M=s-v;M!==0&&(b=Ut(p)/c);const C=fn+xe*(m*v+b*M);C<f&&(r=u,f=C,o=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:o}}function Ii(t,n,e,i){let s=0;for(let a=n,r=n+e;a<r;a++)s+=t[a*6+i*2];return s/e}class Ae{constructor(){this.boundingData=new Float32Array(6)}}function $i(t,n,e,i,s,a){let r=i,o=i+s-1;const c=a.pos,f=a.axis*2;for(;;){for(;r<=o&&e[r*6+f]<c;)r++;for(;r<=o&&e[o*6+f]>=c;)o--;if(r<o){for(let l=0;l<3;l++){let d=n[r*3+l];n[r*3+l]=n[o*3+l],n[o*3+l]=d}for(let l=0;l<6;l++){let d=e[r*6+l];e[r*6+l]=e[o*6+l],e[o*6+l]=d}r++,o--}else return r}}function qi(t,n,e,i,s,a){let r=i,o=i+s-1;const c=a.pos,f=a.axis*2;for(;;){for(;r<=o&&e[r*6+f]<c;)r++;for(;r<=o&&e[o*6+f]>=c;)o--;if(r<o){let l=t[r];t[r]=t[o],t[o]=l;for(let d=0;d<6;d++){let u=e[r*6+d];e[r*6+d]=e[o*6+d],e[o*6+d]=u}r++,o--}else return r}}function X(t,n){return n[t+15]===65535}function G(t,n){return n[t+6]}function Z(t,n){return n[t+14]}function Y(t){return t+8}function J(t,n){return n[t+6]}function jn(t,n){return n[t+7]}let In,qt,fe,$n;const Hi=Math.pow(2,32);function Re(t){return"count"in t?1:1+Re(t.left)+Re(t.right)}function Wi(t,n,e){return In=new Float32Array(e),qt=new Uint32Array(e),fe=new Uint16Array(e),$n=new Uint8Array(e),Oe(t,n)}function Oe(t,n){const e=t/4,i=t/2,s="count"in n,a=n.boundingData;for(let r=0;r<6;r++)In[e+r]=a[r];if(s)if(n.buffer){const r=n.buffer;$n.set(new Uint8Array(r),t);for(let o=t,c=t+r.byteLength;o<c;o+=Wt){const f=o/2;X(f,fe)||(qt[o/4+6]+=e)}return t+r.byteLength}else{const r=n.offset,o=n.count;return qt[e+6]=r,fe[i+14]=o,fe[i+15]=ge,t+Wt}else{const r=n.left,o=n.right,c=n.splitAxis;let f;if(f=Oe(t+Wt,r),f/4>Hi)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return qt[e+6]=f/4,f=Oe(f,o),qt[e+7]=c,f}}function Ki(t,n){const e=(t.index?t.index.count:t.attributes.position.count)/3,i=e>2**16,s=i?4:2,a=n?new SharedArrayBuffer(e*s):new ArrayBuffer(e*s),r=i?new Uint32Array(a):new Uint16Array(a);for(let o=0,c=r.length;o<c;o++)r[o]=o;return r}function Xi(t,n,e,i,s){const{maxDepth:a,verbose:r,maxLeafTris:o,strategy:c,onProgress:f,indirect:l}=s,d=t._indirectBuffer,u=t.geometry,h=u.index?u.index.array:null,w=l?qi:$i,_=Nt(u),A=new Float32Array(6);let y=!1;const v=new Ae;return we(n,e,i,v.boundingData,A),x(v,e,i,A),v;function g(S){f&&f(S/_)}function x(S,T,P,p=null,m=0){if(!y&&m>=a&&(y=!0,r&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(u))),P<=o||m>=a)return g(T+P),S.offset=T,S.count=P,S;const b=ji(S.boundingData,p,n,T,P,c);if(b.axis===-1)return g(T+P),S.offset=T,S.count=P,S;const M=w(d,h,n,T,P,b);if(M===T||M===T+P)g(T+P),S.offset=T,S.count=P;else{S.splitAxis=b.axis;const C=new Ae,E=T,k=M-T;S.left=C,we(n,E,k,C.boundingData,A),x(C,E,k,A,m+1);const O=new Ae,R=M,q=P-k;S.right=O,we(n,R,q,O.boundingData,A),x(O,R,q,A,m+1)}return S}}function Gi(t,n){const e=t.geometry;n.indirect&&(t._indirectBuffer=Ki(e,n.useSharedArrayBuffer),Vi(e)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||Oi(e,n);const i=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Di(e),a=n.indirect?Dn(e):Fn(e);t._roots=a.map(r=>{const o=Xi(t,s,r.offset,r.count,n),c=Re(o),f=new i(Wt*c);return Wi(0,o,f),f})}class ut{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,e){let i=1/0,s=-1/0;for(let a=0,r=n.length;a<r;a++){const c=n[a][e];i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}setFromPoints(n,e){let i=1/0,s=-1/0;for(let a=0,r=e.length;a<r;a++){const o=e[a],c=n.dot(o);i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}isSeparated(n){return this.min>n.max||n.min>this.max}}ut.prototype.setFromBox=function(){const t=new L;return function(e,i){const s=i.min,a=i.max;let r=1/0,o=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){t.x=s.x*c+a.x*(1-c),t.y=s.y*f+a.y*(1-f),t.z=s.z*l+a.z*(1-l);const d=e.dot(t);r=Math.min(d,r),o=Math.max(d,o)}this.min=r,this.max=o}}();const Zi=function(){const t=new L,n=new L,e=new L;return function(s,a,r){const o=s.start,c=t,f=a.start,l=n;e.subVectors(o,f),t.subVectors(s.end,s.start),n.subVectors(a.end,a.start);const d=e.dot(l),u=l.dot(c),h=l.dot(l),w=e.dot(c),A=c.dot(c)*h-u*u;let y,v;A!==0?y=(d*u-w*h)/A:y=0,v=(d+y*u)/h,r.x=y,r.y=v}}(),Xe=function(){const t=new Et,n=new L,e=new L;return function(s,a,r,o){Zi(s,a,t);let c=t.x,f=t.y;if(c>=0&&c<=1&&f>=0&&f<=1){s.at(c,r),a.at(f,o);return}else if(c>=0&&c<=1){f<0?a.at(0,o):a.at(1,o),s.closestPointToPoint(o,!0,r);return}else if(f>=0&&f<=1){c<0?s.at(0,r):s.at(1,r),a.closestPointToPoint(r,!0,o);return}else{let l;c<0?l=s.start:l=s.end;let d;f<0?d=a.start:d=a.end;const u=n,h=e;if(s.closestPointToPoint(d,!0,n),a.closestPointToPoint(l,!0,e),u.distanceToSquared(d)<=h.distanceToSquared(l)){r.copy(u),o.copy(d);return}else{r.copy(l),o.copy(h);return}}}}(),Yi=function(){const t=new L,n=new L,e=new Nn,i=new lt;return function(a,r){const{radius:o,center:c}=a,{a:f,b:l,c:d}=r;if(i.start=f,i.end=l,i.closestPointToPoint(c,!0,t).distanceTo(c)<=o||(i.start=f,i.end=d,i.closestPointToPoint(c,!0,t).distanceTo(c)<=o)||(i.start=l,i.end=d,i.closestPointToPoint(c,!0,t).distanceTo(c)<=o))return!0;const _=r.getPlane(e);if(Math.abs(_.distanceToPoint(c))<=o){const y=_.projectPoint(c,n);if(r.containsPoint(y))return!0}return!1}}(),Ji=1e-15;function Se(t){return Math.abs(t)<Ji}class it extends It{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new ut),this.points=[this.a,this.b,this.c],this.sphere=new fi,this.plane=new Nn,this.needsUpdate=!0}intersectsSphere(n){return Yi(n,this)}update(){const n=this.a,e=this.b,i=this.c,s=this.points,a=this.satAxes,r=this.satBounds,o=a[0],c=r[0];this.getNormal(o),c.setFromPoints(o,s);const f=a[1],l=r[1];f.subVectors(n,e),l.setFromPoints(f,s);const d=a[2],u=r[2];d.subVectors(e,i),u.setFromPoints(d,s);const h=a[3],w=r[3];h.subVectors(i,n),w.setFromPoints(h,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,n),this.needsUpdate=!1}}it.prototype.closestPointToSegment=function(){const t=new L,n=new L,e=new lt;return function(s,a=null,r=null){const{start:o,end:c}=s,f=this.points;let l,d=1/0;for(let u=0;u<3;u++){const h=(u+1)%3;e.start.copy(f[u]),e.end.copy(f[h]),Xe(e,s,t,n),l=t.distanceToSquared(n),l<d&&(d=l,a&&a.copy(t),r&&r.copy(n))}return this.closestPointToPoint(o,t),l=o.distanceToSquared(t),l<d&&(d=l,a&&a.copy(t),r&&r.copy(o)),this.closestPointToPoint(c,t),l=c.distanceToSquared(t),l<d&&(d=l,a&&a.copy(t),r&&r.copy(c)),Math.sqrt(d)}}();it.prototype.intersectsTriangle=function(){const t=new it,n=new Array(3),e=new Array(3),i=new ut,s=new ut,a=new L,r=new L,o=new L,c=new L,f=new L,l=new lt,d=new lt,u=new lt,h=new L;function w(_,A,y){const v=_.points;let g=0,x=-1;for(let S=0;S<3;S++){const{start:T,end:P}=l;T.copy(v[S]),P.copy(v[(S+1)%3]),l.delta(r);const p=Se(A.distanceToPoint(T));if(Se(A.normal.dot(r))&&p){y.copy(l),g=2;break}const m=A.intersectLine(l,h);if(!m&&p&&h.copy(T),(m||p)&&!Se(h.distanceTo(P))){if(g<=1)(g===1?y.start:y.end).copy(h),p&&(x=g);else if(g>=2){(x===1?y.start:y.end).copy(h),g=2;break}if(g++,g===2&&x===-1)break}}return g}return function(A,y=null,v=!1){this.needsUpdate&&this.update(),A.isExtendedTriangle?A.needsUpdate&&A.update():(t.copy(A),t.update(),A=t);const g=this.plane,x=A.plane;if(Math.abs(g.normal.dot(x.normal))>1-1e-10){const S=this.satBounds,T=this.satAxes;e[0]=A.a,e[1]=A.b,e[2]=A.c;for(let m=0;m<4;m++){const b=S[m],M=T[m];if(i.setFromPoints(M,e),b.isSeparated(i))return!1}const P=A.satBounds,p=A.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let m=0;m<4;m++){const b=P[m],M=p[m];if(i.setFromPoints(M,n),b.isSeparated(i))return!1}for(let m=0;m<4;m++){const b=T[m];for(let M=0;M<4;M++){const C=p[M];if(a.crossVectors(b,C),i.setFromPoints(a,n),s.setFromPoints(a,e),i.isSeparated(s))return!1}}return y&&(v||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const S=w(this,x,d);if(S===1&&A.containsPoint(d.end))return y&&(y.start.copy(d.end),y.end.copy(d.end)),!0;if(S!==2)return!1;const T=w(A,g,u);if(T===1&&this.containsPoint(u.end))return y&&(y.start.copy(u.end),y.end.copy(u.end)),!0;if(T!==2)return!1;if(d.delta(o),u.delta(c),o.dot(c)<0){let E=u.start;u.start=u.end,u.end=E}const P=d.start.dot(o),p=d.end.dot(o),m=u.start.dot(o),b=u.end.dot(o),M=p<m,C=P<b;return P!==b&&m!==p&&M===C?!1:(y&&(f.subVectors(d.start,u.start),f.dot(o)>0?y.start.copy(d.start):y.start.copy(u.start),f.subVectors(d.end,u.end),f.dot(o)<0?y.end.copy(d.end):y.end.copy(u.end)),!0)}}}();it.prototype.distanceToPoint=function(){const t=new L;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}();it.prototype.distanceToTriangle=function(){const t=new L,n=new L,e=["a","b","c"],i=new lt,s=new lt;return function(r,o=null,c=null){const f=o||c?i:null;if(this.intersectsTriangle(r,f))return(o||c)&&(o&&f.getCenter(o),c&&f.getCenter(c)),0;let l=1/0;for(let d=0;d<3;d++){let u;const h=e[d],w=r[h];this.closestPointToPoint(w,t),u=w.distanceToSquared(t),u<l&&(l=u,o&&o.copy(t),c&&c.copy(w));const _=this[h];r.closestPointToPoint(_,t),u=_.distanceToSquared(t),u<l&&(l=u,o&&o.copy(_),c&&c.copy(t))}for(let d=0;d<3;d++){const u=e[d],h=e[(d+1)%3];i.set(this[u],this[h]);for(let w=0;w<3;w++){const _=e[w],A=e[(w+1)%3];s.set(r[_],r[A]),Xe(i,s,t,n);const y=t.distanceToSquared(n);y<l&&(l=y,o&&o.copy(t),c&&c.copy(n))}}return Math.sqrt(l)}}();class K{constructor(n,e,i){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new mt,this.invMatrix=new mt,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new ut),this.alignedSatBounds=new Array(3).fill().map(()=>new ut),this.needsUpdate=!1,n&&this.min.copy(n),e&&this.max.copy(e),i&&this.matrix.copy(i)}set(n,e,i){this.min.copy(n),this.max.copy(e),this.matrix.copy(i),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}K.prototype.update=function(){return function(){const n=this.matrix,e=this.min,i=this.max,s=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const u=1*f|2*l|4*d,h=s[u];h.x=f?i.x:e.x,h.y=l?i.y:e.y,h.z=d?i.z:e.z,h.applyMatrix4(n)}const a=this.satBounds,r=this.satAxes,o=s[0];for(let f=0;f<3;f++){const l=r[f],d=a[f],u=1<<f,h=s[u];l.subVectors(o,h),d.setFromPoints(l,s)}const c=this.alignedSatBounds;c[0].setFromPointsField(s,"x"),c[1].setFromPointsField(s,"y"),c[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();K.prototype.intersectsBox=function(){const t=new ut;return function(e){this.needsUpdate&&this.update();const i=e.min,s=e.max,a=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(t.min=i.x,t.max=s.x,o[0].isSeparated(t)||(t.min=i.y,t.max=s.y,o[1].isSeparated(t))||(t.min=i.z,t.max=s.z,o[2].isSeparated(t)))return!1;for(let c=0;c<3;c++){const f=r[c],l=a[c];if(t.setFromBox(f,e),l.isSeparated(t))return!1}return!0}}();K.prototype.intersectsTriangle=function(){const t=new it,n=new Array(3),e=new ut,i=new ut,s=new L;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const o=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let u=0;u<3;u++){const h=o[u],w=c[u];if(e.setFromPoints(w,n),h.isSeparated(e))return!1}const f=r.satBounds,l=r.satAxes,d=this.points;for(let u=0;u<3;u++){const h=f[u],w=l[u];if(e.setFromPoints(w,d),h.isSeparated(e))return!1}for(let u=0;u<3;u++){const h=c[u];for(let w=0;w<4;w++){const _=l[w];if(s.crossVectors(h,_),e.setFromPoints(s,n),i.setFromPoints(s,d),e.isSeparated(i))return!1}}return!0}}();K.prototype.closestPointToPoint=function(){return function(n,e){return this.needsUpdate&&this.update(),e.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();K.prototype.distanceToPoint=function(){const t=new L;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}();K.prototype.distanceToBox=function(){const t=["x","y","z"],n=new Array(12).fill().map(()=>new lt),e=new Array(12).fill().map(()=>new lt),i=new L,s=new L;return function(r,o=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||f)&&(r.getCenter(s),this.closestPointToPoint(s,i),r.closestPointToPoint(i,s),c&&c.copy(i),f&&f.copy(s)),0;const l=o*o,d=r.min,u=r.max,h=this.points;let w=1/0;for(let A=0;A<8;A++){const y=h[A];s.copy(y).clamp(d,u);const v=y.distanceToSquared(s);if(v<w&&(w=v,c&&c.copy(y),f&&f.copy(s),v<l))return Math.sqrt(v)}let _=0;for(let A=0;A<3;A++)for(let y=0;y<=1;y++)for(let v=0;v<=1;v++){const g=(A+1)%3,x=(A+2)%3,S=y<<g|v<<x,T=1<<A|y<<g|v<<x,P=h[S],p=h[T];n[_].set(P,p);const b=t[A],M=t[g],C=t[x],E=e[_],k=E.start,O=E.end;k[b]=d[b],k[M]=y?d[M]:u[M],k[C]=v?d[C]:u[M],O[b]=u[b],O[M]=y?d[M]:u[M],O[C]=v?d[C]:u[M],_++}for(let A=0;A<=1;A++)for(let y=0;y<=1;y++)for(let v=0;v<=1;v++){s.x=A?u.x:d.x,s.y=y?u.y:d.y,s.z=v?u.z:d.z,this.closestPointToPoint(s,i);const g=s.distanceToSquared(i);if(g<w&&(w=g,c&&c.copy(i),f&&f.copy(s),g<l))return Math.sqrt(g)}for(let A=0;A<12;A++){const y=n[A];for(let v=0;v<12;v++){const g=e[v];Xe(y,g,i,s);const x=i.distanceToSquared(s);if(x<w&&(w=x,c&&c.copy(i),f&&f.copy(s),x<l))return Math.sqrt(x)}}return Math.sqrt(w)}}();class Ge{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class Qi extends Ge{constructor(){super(()=>new it)}}const Q=new Qi;class ts{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let e=null;this.setBuffer=i=>{e&&n.push(e),e=i,this.float32Array=new Float32Array(i),this.uint16Array=new Uint16Array(i),this.uint32Array=new Uint32Array(i)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const V=new ts;let pt,Mt;const vt=[],Yt=new Ge(()=>new ot);function es(t,n,e,i,s,a){pt=Yt.getPrimitive(),Mt=Yt.getPrimitive(),vt.push(pt,Mt),V.setBuffer(t._roots[n]);const r=Ve(0,t.geometry,e,i,s,a);V.clearBuffer(),Yt.releasePrimitive(pt),Yt.releasePrimitive(Mt),vt.pop(),vt.pop();const o=vt.length;return o>0&&(Mt=vt[o-1],pt=vt[o-2]),r}function Ve(t,n,e,i,s=null,a=0,r=0){const{float32Array:o,uint16Array:c,uint32Array:f}=V;let l=t*2;if(X(l,c)){const u=G(t,f),h=Z(l,c);return F(t,o,pt),i(u,h,!1,r,a+t,pt)}else{let b=function(C){const{uint16Array:E,uint32Array:k}=V;let O=C*2;for(;!X(O,E);)C=Y(C),O=C*2;return G(C,k)},M=function(C){const{uint16Array:E,uint32Array:k}=V;let O=C*2;for(;!X(O,E);)C=J(C,k),O=C*2;return G(C,k)+Z(O,E)};const u=Y(t),h=J(t,f);let w=u,_=h,A,y,v,g;if(s&&(v=pt,g=Mt,F(w,o,v),F(_,o,g),A=s(v),y=s(g),y<A)){w=h,_=u;const C=A;A=y,y=C,v=g}v||(v=pt,F(w,o,v));const x=X(w*2,c),S=e(v,x,A,r+1,a+w);let T;if(S===un){const C=b(w),k=M(w)-C;T=i(C,k,!0,r+1,a+w,v)}else T=S&&Ve(w,n,e,i,s,a,r+1);if(T)return!0;g=Mt,F(_,o,g);const P=X(_*2,c),p=e(g,P,y,r+1,a+_);let m;if(p===un){const C=b(_),k=M(_)-C;m=i(C,k,!0,r+1,a+_,g)}else m=p&&Ve(_,n,e,i,s,a,r+1);return!!m}}const Rt=new L,Pe=new L;function ns(t,n,e={},i=0,s=1/0){const a=i*i,r=s*s;let o=1/0,c=null;if(t.shapecast({boundsTraverseOrder:l=>(Rt.copy(n).clamp(l.min,l.max),Rt.distanceToSquared(n)),intersectsBounds:(l,d,u)=>u<o&&u<r,intersectsTriangle:(l,d)=>{l.closestPointToPoint(n,Rt);const u=n.distanceToSquared(Rt);return u<o&&(Pe.copy(Rt),o=u,c=d),u<a}}),o===1/0)return null;const f=Math.sqrt(o);return e.point?e.point.copy(Pe):e.point=Pe.clone(),e.distance=f,e.faceIndex=c,e}const xt=new L,bt=new L,wt=new L,Jt=new Et,Qt=new Et,te=new Et,hn=new L,yn=new L,gn=new L,ee=new L;function is(t,n,e,i,s,a){let r;return a===En?r=t.intersectTriangle(i,e,n,!0,s):r=t.intersectTriangle(n,e,i,a!==di,s),r===null?null:{distance:t.origin.distanceTo(s),point:s.clone()}}function ss(t,n,e,i,s,a,r,o,c){xt.fromBufferAttribute(n,a),bt.fromBufferAttribute(n,r),wt.fromBufferAttribute(n,o);const f=is(t,xt,bt,wt,ee,c);if(f){i&&(Jt.fromBufferAttribute(i,a),Qt.fromBufferAttribute(i,r),te.fromBufferAttribute(i,o),f.uv=It.getInterpolation(ee,xt,bt,wt,Jt,Qt,te,new Et)),s&&(Jt.fromBufferAttribute(s,a),Qt.fromBufferAttribute(s,r),te.fromBufferAttribute(s,o),f.uv1=It.getInterpolation(ee,xt,bt,wt,Jt,Qt,te,new Et)),e&&(hn.fromBufferAttribute(e,a),yn.fromBufferAttribute(e,r),gn.fromBufferAttribute(e,o),f.normal=It.getInterpolation(ee,xt,bt,wt,hn,yn,gn,new L),f.normal.dot(t.direction)>0&&f.normal.multiplyScalar(-1));const l={a,b:r,c:o,normal:new L,materialIndex:0};It.getNormal(xt,bt,wt,l.normal),f.face=l,f.faceIndex=a}return f}function ve(t,n,e,i,s){const a=i*3;let r=a+0,o=a+1,c=a+2;const f=t.index;t.index&&(r=f.getX(r),o=f.getX(o),c=f.getX(c));const{position:l,normal:d,uv:u,uv1:h}=t.attributes,w=ss(e,l,d,u,h,r,o,c,n);return w?(w.faceIndex=i,s&&s.push(w),w):null}function I(t,n,e,i){const s=t.a,a=t.b,r=t.c;let o=n,c=n+1,f=n+2;e&&(o=e.getX(o),c=e.getX(c),f=e.getX(f)),s.x=i.getX(o),s.y=i.getY(o),s.z=i.getZ(o),a.x=i.getX(c),a.y=i.getY(c),a.z=i.getZ(c),r.x=i.getX(f),r.y=i.getY(f),r.z=i.getZ(f)}function rs(t,n,e,i,s,a){const{geometry:r,_indirectBuffer:o}=t;for(let c=i,f=i+s;c<f;c++)ve(r,n,e,c,a)}function os(t,n,e,i,s){const{geometry:a,_indirectBuffer:r}=t;let o=1/0,c=null;for(let f=i,l=i+s;f<l;f++){let d;d=ve(a,n,e,f),d&&d.distance<o&&(c=d,o=d.distance)}return c}function cs(t,n,e,i,s,a,r){const{geometry:o}=e,{index:c}=o,f=o.attributes.position;for(let l=t,d=n+t;l<d;l++){let u;if(u=l,I(r,u*3,c,f),r.needsUpdate=!0,i(r,u,s,a))return!0}return!1}function as(t,n=null){n&&Array.isArray(n)&&(n=new Set(n));const e=t.geometry,i=e.index?e.index.array:null,s=e.attributes.position;let a,r,o,c,f=0;const l=t._roots;for(let u=0,h=l.length;u<h;u++)a=l[u],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),d(0,f),f+=a.byteLength;function d(u,h,w=!1){const _=u*2;if(o[_+15]===ge){const y=r[u+6],v=o[_+14];let g=1/0,x=1/0,S=1/0,T=-1/0,P=-1/0,p=-1/0;for(let m=3*y,b=3*(y+v);m<b;m++){let M=i[m];const C=s.getX(M),E=s.getY(M),k=s.getZ(M);C<g&&(g=C),C>T&&(T=C),E<x&&(x=E),E>P&&(P=E),k<S&&(S=k),k>p&&(p=k)}return c[u+0]!==g||c[u+1]!==x||c[u+2]!==S||c[u+3]!==T||c[u+4]!==P||c[u+5]!==p?(c[u+0]=g,c[u+1]=x,c[u+2]=S,c[u+3]=T,c[u+4]=P,c[u+5]=p,!0):!1}else{const y=u+8,v=r[u+6],g=y+h,x=v+h;let S=w,T=!1,P=!1;n?S||(T=n.has(g),P=n.has(x),S=!T&&!P):(T=!0,P=!0);const p=S||T,m=S||P;let b=!1;p&&(b=d(y,h,S));let M=!1;m&&(M=d(v,h,S));const C=b||M;if(C)for(let E=0;E<3;E++){const k=y+E,O=v+E,R=c[k],q=c[k+3],st=c[O],ct=c[O+3];c[u+E]=R<st?R:st,c[u+E+3]=q>ct?q:ct}return C}}}function ht(t,n,e){let i,s,a,r,o,c;const f=1/e.direction.x,l=1/e.direction.y,d=1/e.direction.z,u=e.origin.x,h=e.origin.y,w=e.origin.z;let _=n[t],A=n[t+3],y=n[t+1],v=n[t+3+1],g=n[t+2],x=n[t+3+2];return f>=0?(i=(_-u)*f,s=(A-u)*f):(i=(A-u)*f,s=(_-u)*f),l>=0?(a=(y-h)*l,r=(v-h)*l):(a=(v-h)*l,r=(y-h)*l),!(i>r||a>s||((a>i||isNaN(i))&&(i=a),(r<s||isNaN(s))&&(s=r),d>=0?(o=(g-w)*d,c=(x-w)*d):(o=(x-w)*d,c=(g-w)*d),i>c||o>s)||((c<s||s!==s)&&(s=c),s<0))}function ls(t,n,e,i,s,a){const{geometry:r,_indirectBuffer:o}=t;for(let c=i,f=i+s;c<f;c++){let l=o?o[c]:c;ve(r,n,e,l,a)}}function us(t,n,e,i,s){const{geometry:a,_indirectBuffer:r}=t;let o=1/0,c=null;for(let f=i,l=i+s;f<l;f++){let d;d=ve(a,n,e,r?r[f]:f),d&&d.distance<o&&(c=d,o=d.distance)}return c}function fs(t,n,e,i,s,a,r){const{geometry:o}=e,{index:c}=o,f=o.attributes.position;for(let l=t,d=n+t;l<d;l++){let u;if(u=e.resolveTriangleIndex(l),I(r,u*3,c,f),r.needsUpdate=!0,i(r,u,s,a))return!0}return!1}function ds(t,n,e,i,s){V.setBuffer(t._roots[n]),De(0,t,e,i,s),V.clearBuffer()}function De(t,n,e,i,s){const{float32Array:a,uint16Array:r,uint32Array:o}=V,c=t*2;if(X(c,r)){const l=G(t,o),d=Z(c,r);rs(n,e,i,l,d,s)}else{const l=Y(t);ht(l,a,i)&&De(l,n,e,i,s);const d=J(t,o);ht(d,a,i)&&De(d,n,e,i,s)}}const ps=["x","y","z"];function ms(t,n,e,i){V.setBuffer(t._roots[n]);const s=Fe(0,t,e,i);return V.clearBuffer(),s}function Fe(t,n,e,i){const{float32Array:s,uint16Array:a,uint32Array:r}=V;let o=t*2;if(X(o,a)){const f=G(t,r),l=Z(o,a);return os(n,e,i,f,l)}else{const f=jn(t,r),l=ps[f],u=i.direction[l]>=0;let h,w;u?(h=Y(t),w=J(t,r)):(h=J(t,r),w=Y(t));const A=ht(h,s,i)?Fe(h,n,e,i):null;if(A){const g=A.point[l];if(u?g<=s[w+f]:g>=s[w+f+3])return A}const v=ht(w,s,i)?Fe(w,n,e,i):null;return A&&v?A.distance<=v.distance?A:v:A||v||null}}const ne=new ot,At=new it,St=new it,Ot=new mt,vn=new K,ie=new K;function hs(t,n,e,i){V.setBuffer(t._roots[n]);const s=je(0,t,e,i);return V.clearBuffer(),s}function je(t,n,e,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:o}=V;let c=t*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),vn.set(e.boundingBox.min,e.boundingBox.max,i),s=vn),X(c,r)){const l=n.geometry,d=l.index,u=l.attributes.position,h=e.index,w=e.attributes.position,_=G(t,o),A=Z(c,r);if(Ot.copy(i).invert(),e.boundsTree)return F(t,a,ie),ie.matrix.copy(Ot),ie.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:v=>ie.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(i),v.b.applyMatrix4(i),v.c.applyMatrix4(i),v.needsUpdate=!0;for(let g=_*3,x=(A+_)*3;g<x;g+=3)if(I(St,g,d,u),St.needsUpdate=!0,v.intersectsTriangle(St))return!0;return!1}});for(let y=_*3,v=(A+_)*3;y<v;y+=3){I(At,y,d,u),At.a.applyMatrix4(Ot),At.b.applyMatrix4(Ot),At.c.applyMatrix4(Ot),At.needsUpdate=!0;for(let g=0,x=h.count;g<x;g+=3)if(I(St,g,h,w),St.needsUpdate=!0,At.intersectsTriangle(St))return!0}}else{const l=t+8,d=o[t+6];return F(l,a,ne),!!(s.intersectsBox(ne)&&je(l,n,e,i,s)||(F(d,a,ne),s.intersectsBox(ne)&&je(d,n,e,i,s)))}}const se=new mt,Te=new K,Vt=new K,ys=new L,gs=new L,vs=new L,xs=new L;function bs(t,n,e,i={},s={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Te.set(n.boundingBox.min,n.boundingBox.max,e),Te.needsUpdate=!0;const o=t.geometry,c=o.attributes.position,f=o.index,l=n.attributes.position,d=n.index,u=Q.getPrimitive(),h=Q.getPrimitive();let w=ys,_=gs,A=null,y=null;s&&(A=vs,y=xs);let v=1/0,g=null,x=null;return se.copy(e).invert(),Vt.matrix.copy(se),t.shapecast({boundsTraverseOrder:S=>Te.distanceToBox(S),intersectsBounds:(S,T,P)=>P<v&&P<r?(T&&(Vt.min.copy(S.min),Vt.max.copy(S.max),Vt.needsUpdate=!0),!0):!1,intersectsRange:(S,T)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:p=>Vt.distanceToBox(p),intersectsBounds:(p,m,b)=>b<v&&b<r,intersectsRange:(p,m)=>{for(let b=p,M=p+m;b<M;b++){I(h,3*b,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let C=S,E=S+T;C<E;C++){I(u,3*C,f,c),u.needsUpdate=!0;const k=u.distanceToTriangle(h,w,A);if(k<v&&(_.copy(w),y&&y.copy(A),v=k,g=C,x=b),k<a)return!0}}}});{const P=Nt(n);for(let p=0,m=P;p<m;p++){I(h,3*p,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let b=S,M=S+T;b<M;b++){I(u,3*b,f,c),u.needsUpdate=!0;const C=u.distanceToTriangle(h,w,A);if(C<v&&(_.copy(w),y&&y.copy(A),v=C,g=b,x=p),C<a)return!0}}}}}),Q.releasePrimitive(u),Q.releasePrimitive(h),v===1/0?null:(i.point?i.point.copy(_):i.point=_.clone(),i.distance=v,i.faceIndex=g,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(se),_.applyMatrix4(se),s.distance=_.sub(s.point).length(),s.faceIndex=x),i)}function ws(t,n=null){n&&Array.isArray(n)&&(n=new Set(n));const e=t.geometry,i=e.index?e.index.array:null,s=e.attributes.position;let a,r,o,c,f=0;const l=t._roots;for(let u=0,h=l.length;u<h;u++)a=l[u],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),d(0,f),f+=a.byteLength;function d(u,h,w=!1){const _=u*2;if(o[_+15]===ge){const y=r[u+6],v=o[_+14];let g=1/0,x=1/0,S=1/0,T=-1/0,P=-1/0,p=-1/0;for(let m=y,b=y+v;m<b;m++){const M=3*t.resolveTriangleIndex(m);for(let C=0;C<3;C++){let E=M+C;E=i?i[E]:E;const k=s.getX(E),O=s.getY(E),R=s.getZ(E);k<g&&(g=k),k>T&&(T=k),O<x&&(x=O),O>P&&(P=O),R<S&&(S=R),R>p&&(p=R)}}return c[u+0]!==g||c[u+1]!==x||c[u+2]!==S||c[u+3]!==T||c[u+4]!==P||c[u+5]!==p?(c[u+0]=g,c[u+1]=x,c[u+2]=S,c[u+3]=T,c[u+4]=P,c[u+5]=p,!0):!1}else{const y=u+8,v=r[u+6],g=y+h,x=v+h;let S=w,T=!1,P=!1;n?S||(T=n.has(g),P=n.has(x),S=!T&&!P):(T=!0,P=!0);const p=S||T,m=S||P;let b=!1;p&&(b=d(y,h,S));let M=!1;m&&(M=d(v,h,S));const C=b||M;if(C)for(let E=0;E<3;E++){const k=y+E,O=v+E,R=c[k],q=c[k+3],st=c[O],ct=c[O+3];c[u+E]=R<st?R:st,c[u+E+3]=q>ct?q:ct}return C}}}function As(t,n,e,i,s){V.setBuffer(t._roots[n]),Ie(0,t,e,i,s),V.clearBuffer()}function Ie(t,n,e,i,s){const{float32Array:a,uint16Array:r,uint32Array:o}=V,c=t*2;if(X(c,r)){const l=G(t,o),d=Z(c,r);ls(n,e,i,l,d,s)}else{const l=Y(t);ht(l,a,i)&&Ie(l,n,e,i,s);const d=J(t,o);ht(d,a,i)&&Ie(d,n,e,i,s)}}const Ss=["x","y","z"];function Ps(t,n,e,i){V.setBuffer(t._roots[n]);const s=$e(0,t,e,i);return V.clearBuffer(),s}function $e(t,n,e,i){const{float32Array:s,uint16Array:a,uint32Array:r}=V;let o=t*2;if(X(o,a)){const f=G(t,r),l=Z(o,a);return us(n,e,i,f,l)}else{const f=jn(t,r),l=Ss[f],u=i.direction[l]>=0;let h,w;u?(h=Y(t),w=J(t,r)):(h=J(t,r),w=Y(t));const A=ht(h,s,i)?$e(h,n,e,i):null;if(A){const g=A.point[l];if(u?g<=s[w+f]:g>=s[w+f+3])return A}const v=ht(w,s,i)?$e(w,n,e,i):null;return A&&v?A.distance<=v.distance?A:v:A||v||null}}const re=new ot,Pt=new it,Tt=new it,Dt=new mt,xn=new K,oe=new K;function Ts(t,n,e,i){V.setBuffer(t._roots[n]);const s=qe(0,t,e,i);return V.clearBuffer(),s}function qe(t,n,e,i,s=null){const{float32Array:a,uint16Array:r,uint32Array:o}=V;let c=t*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),xn.set(e.boundingBox.min,e.boundingBox.max,i),s=xn),X(c,r)){const l=n.geometry,d=l.index,u=l.attributes.position,h=e.index,w=e.attributes.position,_=G(t,o),A=Z(c,r);if(Dt.copy(i).invert(),e.boundsTree)return F(t,a,oe),oe.matrix.copy(Dt),oe.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:v=>oe.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(i),v.b.applyMatrix4(i),v.c.applyMatrix4(i),v.needsUpdate=!0;for(let g=_,x=A+_;g<x;g++)if(I(Tt,3*n.resolveTriangleIndex(g),d,u),Tt.needsUpdate=!0,v.intersectsTriangle(Tt))return!0;return!1}});for(let y=_,v=A+_;y<v;y++){const g=n.resolveTriangleIndex(y);I(Pt,3*g,d,u),Pt.a.applyMatrix4(Dt),Pt.b.applyMatrix4(Dt),Pt.c.applyMatrix4(Dt),Pt.needsUpdate=!0;for(let x=0,S=h.count;x<S;x+=3)if(I(Tt,x,h,w),Tt.needsUpdate=!0,Pt.intersectsTriangle(Tt))return!0}}else{const l=t+8,d=o[t+6];return F(l,a,re),!!(s.intersectsBox(re)&&qe(l,n,e,i,s)||(F(d,a,re),s.intersectsBox(re)&&qe(d,n,e,i,s)))}}const ce=new mt,Ce=new K,Ft=new K,Cs=new L,_s=new L,Bs=new L,Ms=new L;function Es(t,n,e,i={},s={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Ce.set(n.boundingBox.min,n.boundingBox.max,e),Ce.needsUpdate=!0;const o=t.geometry,c=o.attributes.position,f=o.index,l=n.attributes.position,d=n.index,u=Q.getPrimitive(),h=Q.getPrimitive();let w=Cs,_=_s,A=null,y=null;s&&(A=Bs,y=Ms);let v=1/0,g=null,x=null;return ce.copy(e).invert(),Ft.matrix.copy(ce),t.shapecast({boundsTraverseOrder:S=>Ce.distanceToBox(S),intersectsBounds:(S,T,P)=>P<v&&P<r?(T&&(Ft.min.copy(S.min),Ft.max.copy(S.max),Ft.needsUpdate=!0),!0):!1,intersectsRange:(S,T)=>{if(n.boundsTree){const P=n.boundsTree;return P.shapecast({boundsTraverseOrder:p=>Ft.distanceToBox(p),intersectsBounds:(p,m,b)=>b<v&&b<r,intersectsRange:(p,m)=>{for(let b=p,M=p+m;b<M;b++){const C=P.resolveTriangleIndex(b);I(h,3*C,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let E=S,k=S+T;E<k;E++){const O=t.resolveTriangleIndex(E);I(u,3*O,f,c),u.needsUpdate=!0;const R=u.distanceToTriangle(h,w,A);if(R<v&&(_.copy(w),y&&y.copy(A),v=R,g=E,x=b),R<a)return!0}}}})}else{const P=Nt(n);for(let p=0,m=P;p<m;p++){I(h,3*p,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let b=S,M=S+T;b<M;b++){const C=t.resolveTriangleIndex(b);I(u,3*C,f,c),u.needsUpdate=!0;const E=u.distanceToTriangle(h,w,A);if(E<v&&(_.copy(w),y&&y.copy(A),v=E,g=b,x=p),E<a)return!0}}}}}),Q.releasePrimitive(u),Q.releasePrimitive(h),v===1/0?null:(i.point?i.point.copy(_):i.point=_.clone(),i.distance=v,i.faceIndex=g,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(ce),_.applyMatrix4(ce),s.distance=_.sub(s.point).length(),s.faceIndex=x),i)}function zs(){return typeof SharedArrayBuffer<"u"}const Kt=new V.constructor,pe=new V.constructor,dt=new Ge(()=>new ot),Ct=new ot,_t=new ot,_e=new ot,Be=new ot;let Me=!1;function Ns(t,n,e,i){if(Me)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Me=!0;const s=t._roots,a=n._roots;let r,o=0,c=0;const f=new mt().copy(e).invert();for(let l=0,d=s.length;l<d;l++){Kt.setBuffer(s[l]),c=0;const u=dt.getPrimitive();F(0,Kt.float32Array,u),u.applyMatrix4(f);for(let h=0,w=a.length;h<w&&(pe.setBuffer(a[l]),r=tt(0,0,e,f,i,o,c,0,0,u),pe.clearBuffer(),c+=a[h].length,!r);h++);if(dt.releasePrimitive(u),Kt.clearBuffer(),o+=s[l].length,r)break}return Me=!1,r}function tt(t,n,e,i,s,a=0,r=0,o=0,c=0,f=null,l=!1){let d,u;l?(d=pe,u=Kt):(d=Kt,u=pe);const h=d.float32Array,w=d.uint32Array,_=d.uint16Array,A=u.float32Array,y=u.uint32Array,v=u.uint16Array,g=t*2,x=n*2,S=X(g,_),T=X(x,v);let P=!1;if(T&&S)l?P=s(G(n,y),Z(n*2,v),G(t,w),Z(t*2,_),c,r+n,o,a+t):P=s(G(t,w),Z(t*2,_),G(n,y),Z(n*2,v),o,a+t,c,r+n);else if(T){const p=dt.getPrimitive();F(n,A,p),p.applyMatrix4(e);const m=Y(t),b=J(t,w);F(m,h,Ct),F(b,h,_t);const M=p.intersectsBox(Ct),C=p.intersectsBox(_t);P=M&&tt(n,m,i,e,s,r,a,c,o+1,p,!l)||C&&tt(n,b,i,e,s,r,a,c,o+1,p,!l),dt.releasePrimitive(p)}else{const p=Y(n),m=J(n,y);F(p,A,_e),F(m,A,Be);const b=f.intersectsBox(_e),M=f.intersectsBox(Be);if(b&&M)P=tt(t,p,e,i,s,a,r,o,c+1,f,l)||tt(t,m,e,i,s,a,r,o,c+1,f,l);else if(b)if(S)P=tt(t,p,e,i,s,a,r,o,c+1,f,l);else{const C=dt.getPrimitive();C.copy(_e).applyMatrix4(e);const E=Y(t),k=J(t,w);F(E,h,Ct),F(k,h,_t);const O=C.intersectsBox(Ct),R=C.intersectsBox(_t);P=O&&tt(p,E,i,e,s,r,a,c,o+1,C,!l)||R&&tt(p,k,i,e,s,r,a,c,o+1,C,!l),dt.releasePrimitive(C)}else if(M)if(S)P=tt(t,m,e,i,s,a,r,o,c+1,f,l);else{const C=dt.getPrimitive();C.copy(Be).applyMatrix4(e);const E=Y(t),k=J(t,w);F(E,h,Ct),F(k,h,_t);const O=C.intersectsBox(Ct),R=C.intersectsBox(_t);P=O&&tt(m,E,i,e,s,r,a,c,o+1,C,!l)||R&&tt(m,k,i,e,s,r,a,c,o+1,C,!l),dt.releasePrimitive(C)}}return P}const ae=new K,bn=new ot,ks={strategy:Vn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Ze{static serialize(n,e={}){e={cloneBuffers:!0,...e};const i=n.geometry,s=n._roots,a=n._indirectBuffer,r=i.getIndex();let o;return e.cloneBuffers?o={roots:s.map(c=>c.slice()),index:r?r.array.slice():null,indirectBuffer:a?a.slice():null}:o={roots:s,index:r?r.array:null,indirectBuffer:a},o}static deserialize(n,e,i={}){i={setIndex:!0,indirect:!!n.indirectBuffer,...i};const{index:s,roots:a,indirectBuffer:r}=n,o=new Ze(e,{...i,[be]:!0});if(o._roots=a,o._indirectBuffer=r||null,i.setIndex){const c=e.getIndex();if(c===null){const f=new zn(n.index,1,!1);e.setIndex(f)}else c.array!==s&&(c.array.set(s),c.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(n,e={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...ks,[be]:!1},e),e.useSharedArrayBuffer&&!zs())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,e[be]||(Gi(this,e),!n.boundingBox&&e.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new ot)));const{_indirectBuffer:i}=this;this.resolveTriangleIndex=e.indirect?s=>i[s]:s=>s}refit(n=null){return(this.indirect?ws:as)(this,n)}traverse(n,e=0){const i=this._roots[e],s=new Uint32Array(i),a=new Uint16Array(i);r(0);function r(o,c=0){const f=o*2,l=a[f+15]===ge;if(l){const d=s[o+6],u=a[f+14];n(c,l,new Float32Array(i,o*4,6),d,u)}else{const d=o+Wt/4,u=s[o+6],h=s[o+7];n(c,l,new Float32Array(i,o*4,6),h)||(r(d,c+1),r(u,c+1))}}}raycast(n,e=cn){const i=this._roots,s=this.geometry,a=[],r=e.isMaterial,o=Array.isArray(e),c=s.groups,f=r?e.side:e,l=this.indirect?As:ds;for(let d=0,u=i.length;d<u;d++){const h=o?e[c[d].materialIndex].side:f,w=a.length;if(l(this,d,h,n,a),o){const _=c[d].materialIndex;for(let A=w,y=a.length;A<y;A++)a[A].face.materialIndex=_}}return a}raycastFirst(n,e=cn){const i=this._roots,s=this.geometry,a=e.isMaterial,r=Array.isArray(e);let o=null;const c=s.groups,f=a?e.side:e,l=this.indirect?Ps:ms;for(let d=0,u=i.length;d<u;d++){const h=r?e[c[d].materialIndex].side:f,w=l(this,d,h,n);w!=null&&(o==null||w.distance<o.distance)&&(o=w,r&&(w.face.materialIndex=c[d].materialIndex))}return o}intersectsGeometry(n,e){let i=!1;const s=this._roots,a=this.indirect?Ts:hs;for(let r=0,o=s.length;r<o&&(i=a(this,r,n,e),!i);r++);return i}shapecast(n){const e=Q.getPrimitive(),i=this.indirect?fs:cs;let{boundsTraverseOrder:s,intersectsBounds:a,intersectsRange:r,intersectsTriangle:o}=n;if(r&&o){const d=r;r=(u,h,w,_,A)=>d(u,h,w,_,A)?!0:i(u,h,this,o,w,_,e)}else r||(o?r=(d,u,h,w)=>i(d,u,this,o,h,w,e):r=(d,u,h)=>h);let c=!1,f=0;const l=this._roots;for(let d=0,u=l.length;d<u;d++){const h=l[d];if(c=es(this,d,a,r,s,f),c)break;f+=h.byteLength}return Q.releasePrimitive(e),c}bvhcast(n,e,i){let{intersectsRanges:s,intersectsTriangles:a}=i;const r=Q.getPrimitive(),o=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?w=>{const _=this.resolveTriangleIndex(w);I(r,_*3,o,c)}:w=>{I(r,w*3,o,c)},l=Q.getPrimitive(),d=n.geometry.index,u=n.geometry.attributes.position,h=n.indirect?w=>{const _=n.resolveTriangleIndex(w);I(l,_*3,d,u)}:w=>{I(l,w*3,d,u)};if(a){const w=(_,A,y,v,g,x,S,T)=>{for(let P=y,p=y+v;P<p;P++){h(P),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let m=_,b=_+A;m<b;m++)if(f(m),r.needsUpdate=!0,a(r,l,m,P,g,x,S,T))return!0}return!1};if(s){const _=s;s=function(A,y,v,g,x,S,T,P){return _(A,y,v,g,x,S,T,P)?!0:w(A,y,v,g,x,S,T,P)}}else s=w}return Ns(this,n,e,s)}intersectsBox(n,e){return ae.set(n.min,n.max,e),ae.needsUpdate=!0,this.shapecast({intersectsBounds:i=>ae.intersectsBox(i),intersectsTriangle:i=>ae.intersectsTriangle(i)})}intersectsSphere(n){return this.shapecast({intersectsBounds:e=>n.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(n)})}closestPointToGeometry(n,e,i={},s={},a=0,r=1/0){return(this.indirect?Es:bs)(this,n,e,i,s,a,r)}closestPointToPoint(n,e={},i=0,s=1/0){return ns(this,n,e,i,s)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(i=>{F(0,new Float32Array(i),bn),n.union(bn)}),n}}function wn(t,n,e){return t===null||(t.point.applyMatrix4(n.matrixWorld),t.distance=t.point.distanceTo(e.ray.origin),t.object=n,t.distance<e.near||t.distance>e.far)?null:t}const Ee=new pi,An=new mt,Ls=kn.prototype.raycast;function Us(t,n){if(this.geometry.boundsTree){if(this.material===void 0)return;An.copy(this.matrixWorld).invert(),Ee.copy(t.ray).applyMatrix4(An);const e=this.geometry.boundsTree;if(t.firstHitOnly===!0){const i=wn(e.raycastFirst(Ee,this.material),this,t);i&&n.push(i)}else{const i=e.raycast(Ee,this.material);for(let s=0,a=i.length;s<a;s++){const r=wn(i[s],this,t);r&&n.push(r)}}}else Ls.call(this,t,n)}function Rs(t){return this.boundsTree=new Ze(this,t),this.boundsTree}function Os(){this.boundsTree=null}function Vs({modelInCopy:t}){const n=new $t({color:15461355});var e=new le({color:10921638,linewidth:10});const i=new Ke(Ln);return i.uniforms.diffuse.value.set(0),B.useEffect(()=>{const s=[];t.traverse(a=>{if(a.frustumCulled=!0,a.isMesh){a.material=n,a.frustumCulled=!1;var r=new ue(a.geometry,20),o=new Ht(r,e);s.push(a.geometry);const c=new mi(hi(a.geometry)),f=new Ht(c,i);a.add(o),a.add(f),r.dispose(),a.geometry.dispose(),n.dispose()}})},[]),z(H,{children:z("primitive",{object:t,scale:1})})}et.memo(Vs);new Si;const Ds={linewidth:{value:1},resolution:{value:new Pi(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1},opacity:{value:1}},ze={uniforms:On.merge([ln.common,ln.fog,Ds]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 control0;
		attribute vec3 control1;
		attribute vec3 direction;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

			// conditional logic
			// Transform the line segment ends and control points into camera clip space
			vec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );
			vec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );
			vec4 p0 = projectionMatrix * modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 p1 = projectionMatrix * modelViewMatrix * vec4( instanceStart + direction, 1.0 );

			c0 /= c0.w;
			c1 /= c1.w;
			p0 /= p0.w;
			p1 /= p1.w;

			// Get the direction of the segment and an orthogonal vector
			vec2 segDir = p1.xy - p0.xy;
			vec2 norm = vec2( - segDir.y, segDir.x );

			// Get control point directions from the line
			vec2 c0dir = c0.xy - p1.xy;
			vec2 c1dir = c1.xy - p1.xy;

			// If the vectors to the controls points are pointed in different directions away
			// from the line segment then the line should not be drawn.
			float d0 = dot( normalize( norm ), normalize( c0dir ) );
			float d1 = dot( normalize( norm ), normalize( c1dir ) );
			float discardFlag = float( sign( d0 ) != sign( d1 ) );
			gl_Position = discardFlag > 0.5 ? c0 : gl_Position;
			// end conditional line logic

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class Fs extends Ti{constructor(n){super({type:"ConditionalLineMaterial",uniforms:On.clone(ze.uniforms),vertexShader:ze.vertexShader,fragmentShader:ze.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(e){this.uniforms.diffuse.value=e}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(e){this.uniforms.linewidth.value=e}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(e){this.uniforms.dashScale.value=e}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(e){this.uniforms.dashSize.value=e}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(e){this.uniforms.gapSize.value=e}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(e){this.uniforms.opacity.value=e}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(e){this.uniforms.resolution.value.copy(e)}}}),this.setValues(n)}}Fs.prototype.isConditionalLineMaterial=!0;yi({OutlineEffect:Mi});const Ne=[],ke=[];function js({modelIn:t,modelOut:n,modelInCopy:e,modelInCopy2:i,modelOutCopy:s}){an.prototype.computeBoundsTree=Rs,an.prototype.disposeBoundsTree=Os,kn.prototype.raycast=Us,console.log("render count");const{gl:a,camera:r,scene:o}=gi(),c=B.useRef(),f=B.useRef();B.useRef(),B.useRef(),B.useRef(),a.setPixelRatio(Math.min(window.devicePixelRatio,2));let{stepCount:l,modelProperties:d,partsInOut:u,setVisibleModel:h,setCurrentStepObj:w,currentStepObject:_,selectedParts:A,setProperties:y,setCurrentObject:v,visibleObj:g}=B.useContext(nt);const[x,S]=B.useState(!1),[T,P]=B.useState(!1),[p,m]=B.useState(i);B.useState();const[b,M]=B.useState(e);B.useState(i);const[C,E]=B.useState();B.useState(),B.useState();const[k,O]=B.useState(),[R,q]=B.useState();B.useState();const st=new $t({color:15461355}),ct=new $t({color:16777215}),Ye=new $t({color:16711680,wireframe:!0}),Je=new $t({color:13754592});var Qe=new le({color:4210752,linewidth:10}),tn=new le({color:6723993,linewidth:50}),Gn=new le({color:10921638,linewidth:10});new Ke(Ln).uniforms.diffuse.value.set(0);const en=["05_Fix_the_shade_on_the_structure"],Xt=[["03_Assemble_the_lamp_shade_-_part_1","04_Assemble_the_lamp_shade_-_part_2"]],Zn=["111_Wiring_1","112_Wiring_2","113_Wiring_3"],nn=[];let sn=[],Lt=[];B.useEffect(()=>{u===!0?(m(i),q(i.getObjectByName(x[l]))):u===!1&&(m(s),q(s.getObjectByName(x[l])))},[u]),B.useEffect(()=>{p.traverse(N=>{N.isObject3D&&!N.isMesh&&!N.isGroup&&(Ne.push(N.name),ke.push(N.userData.name))},[]),Ne.sort(),S(Ne),ke.sort(),P(ke),b.traverse(N=>{if(N.isMesh){N.material=st,N.frustumCulled=!1;var $=new ue(N.geometry,20),U=new Ht($,Gn);N.add(U),N.geometry.dispose(),st.dispose()}}),w(e.getObjectByName(x[0])),q(p.getObjectByName(x[0])),rn(),zt()},[]);const Yn=en.some(N=>N.includes(x[l])),Jn=Xt.some(N=>N.includes(x[l]));W(N=>N.wiringStep);const Qn=W(N=>N.isWiringStep),ti=W(N=>N.isNotWiringStep);Zn.some(N=>N.includes(x[l]))?Qn():ti(),B.useEffect(()=>{w(i.getObjectByName(x[l])),q(p.getObjectByName(x[l]))},[x,l]),B.useEffect(()=>{console.log(_),rn()},[x,l,_]),B.useEffect(()=>{R&&(v(R.getObjectByName(x[l])),A!=[]&&si(),zt())},[A,R]);const rn=B.useCallback(()=>{let N=[],$=[];const U=[];if(_){for(let gt=0;gt<_.children.length;gt++)_.children[gt].traverse(yt=>{yt.isGroup&&yt.userData.name!=null&&U.push(yt.userData.name),N=[...new Set(U)],$=N.map(rt=>[U.filter(ci=>ci===rt).length,rt])});const j=_.userData.name;y({partsNames:$,titleName:j})}}),ei=B.useCallback(()=>{for(let N=l-1;N>=0;N--)for(let $=Lt.length-1;$>=0;$--)if(x[N]===Lt[$]){let U=b.getObjectByName(`${x[N]}`,!0);sn.push(U)}}),ni=B.useCallback(()=>{for(let U=0;U<Xt.length;U++){Lt=Xt[U];for(let j=0;j<Lt.length;j++)Lt.some(yt=>yt.includes(x[l]))&&ei()}let N=new de,$=R.clone();N.add($),sn.filter(U=>Xt.some(j=>j.includes(U.name))).forEach(U=>{U.visible=!0;let j=U.clone();N.add(j)}),h(N)}),ii=B.useCallback(()=>{for(let U=l-1;U>=0;U--){let j=b.getObjectByName(`${x[U]}`,!0);nn.push(j)}let N=new de;nn.filter(U=>!en.some(j=>j.includes(U.name))).forEach(U=>{U.visible=!0;let j=U.clone();N.add(j)});let $=R.clone();N.add($),h(N)}),si=B.useCallback(()=>{if(R){const N=[];for(let $=0;$<R.children.length;$++)R.children[$].traverse(U=>{if(U.isMesh&&A.includes(R.children[$].userData.name)){U.frustumCulled=!1;const rt=U.geometry.clone();N.push(rt),U.material=Je;var j=new ue(U.geometry,20),gt=new Ht(j,tn);U.add(gt),Je.dispose(),j.dispose(),tn.dispose()}else if(U.isMesh&&R.children[$].userData.name!="Curves"){U.frustumCulled=!1,U.material=ct;var j=new ue(U.geometry,20),yt=new Ht(j,Qe);U.add(yt),j.dispose(),Qe.dispose()}else if(U.userData.name==="Curves"&&(U.frustumCulled=!1,U.material=Ye,U.isGroup))for(let rt=0;rt<U.children.length;rt++)U.children[rt].isMesh&&(U.children[rt].frustumCulled=!1,U.children[rt].material=Ye)});O(A)}});B.useCallback(()=>{C.traverse(N=>{N.name==="Botom_Panel"&&console.log(C.userData.name)})}),B.useCallback(N=>{N.stopPropagation(),console.log(N.object)});const ri=B.useCallback(()=>{if(R){R.clone();for(let N=0;N<p.children.length;N++)p.children[N].visible=!1;for(let N=0;N<b.children.length;N++)b.children[N].visible=!1;Yn?(console.log("exception"),R.visible=!0,h(R)):Jn?(console.log("preparing step"),R.visible=!0,ni()):(console.log("main building step"),R.visible=!0,ii())}},[R]);B.useEffect(()=>{ri()},[R]);const{setListOfStep:oi}=B.useContext(nt);return oi(T),B.useState(null),z(H,{children:z(zi,{children:x?D(H,{children:[z("primitive",{ref:c,object:p,scale:1.0001}),z("primitive",{ref:f,object:b,scale:1})]}):null})})}const Is=et.memo(js);function $s(){let t=[],n=new de;const{modelProperties:e,visibleObj:i,currentStepObject:s,setClickedParts:a,selectedParts:r,partsInOut:o,setCurrentPartsModel:c,currentObject:f,partBtnState:l,setPartButtonState:d}=B.useContext(nt),[u,h]=B.useState(null);B.useState(!1);const[w,_]=B.useState(!1),A=W(x=>x.wiringStep),y=B.useCallback(()=>{if(n=new de,t=[],u){console.log(u);for(let x=0;x<f.children.length;x++)if(f.children[x].userData.name===u){const S=f.children[x].clone();n.add(S),t.push(f.children[x].userData.name)}a(t),c(n)}});B.useEffect(()=>{t=[],a(t),y()},[s,u]),B.useEffect(()=>{d(!1),t=[],a(t),c(null)},[s]);const v=()=>{l===!0&&(d(!1),t=[],a(t),c(null)),l===!1&&(d(!0),y())},g=()=>{console.log("disable"),d(!1),t=[],a(t),c(null),h(null)};return z(H,{children:z("div",{children:z("ul",{children:e?e.partsNames.map(([x,S],T)=>z("li",{children:S===u?D("button",{id:`${S}`,style:{backgroundColor:"#669999",color:"#ffffff"},disabled:w,onClick:()=>{l===!0&&g()},className:"parts",children:[D("b",{children:[" ",x,"x"]}),"  ",S]}):A?D("p",{style:{paddingBottom:10},children:[D("b",{children:[" ",x,"x"]}),"  ",S]}):D("button",{id:`${S}`,disabled:w,onClick:()=>{h(S),v()},className:"parts",children:[D("b",{children:[" ",x,"x "]}),"  ",S]})},T)):null})})})}function qs(){const{modelProperties:t}=B.useContext(nt);return z(H,{children:z("div",{children:t?t.titleName:null})})}var qn={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},Sn=et.createContext&&et.createContext(qn),Hs=["attr","size","title"];function Ws(t,n){if(t==null)return{};var e=Ks(t,n),i,s;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(s=0;s<a.length;s++)i=a[s],!(n.indexOf(i)>=0)&&Object.prototype.propertyIsEnumerable.call(t,i)&&(e[i]=t[i])}return e}function Ks(t,n){if(t==null)return{};var e={},i=Object.keys(t),s,a;for(a=0;a<i.length;a++)s=i[a],!(n.indexOf(s)>=0)&&(e[s]=t[s]);return e}function me(){return me=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i])}return t},me.apply(this,arguments)}function Pn(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);n&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable})),e.push.apply(e,i)}return e}function he(t){for(var n=1;n<arguments.length;n++){var e=arguments[n]!=null?arguments[n]:{};n%2?Pn(Object(e),!0).forEach(function(i){Xs(t,i,e[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):Pn(Object(e)).forEach(function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i))})}return t}function Xs(t,n,e){return n=Gs(n),n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function Gs(t){var n=Zs(t,"string");return typeof n=="symbol"?n:String(n)}function Zs(t,n){if(typeof t!="object"||t===null)return t;var e=t[Symbol.toPrimitive];if(e!==void 0){var i=e.call(t,n||"default");if(typeof i!="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(n==="string"?String:Number)(t)}function Hn(t){return t&&t.map((n,e)=>et.createElement(n.tag,he({key:e},n.attr),Hn(n.child)))}function kt(t){return n=>et.createElement(Ys,me({attr:he({},t.attr)},n),Hn(t.child))}function Ys(t){var n=e=>{var{attr:i,size:s,title:a}=t,r=Ws(t,Hs),o=s||e.size||"1em",c;return e.className&&(c=e.className),t.className&&(c=(c?c+" ":"")+t.className),et.createElement("svg",me({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},e.attr,i,r,{className:c,style:he(he({color:t.color||e.color},e.style),t.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),a&&et.createElement("title",null,a),t.children)};return Sn!==void 0?et.createElement(Sn.Consumer,null,e=>n(e)):n(qn)}function Js(t){return kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"},child:[]},{tag:"path",attr:{d:"m18.25 7.6-5.5-3.18a1.49 1.49 0 0 0-1.5 0L5.75 7.6c-.46.27-.75.76-.75 1.3v6.35c0 .54.29 1.03.75 1.3l5.5 3.18c.46.27 1.04.27 1.5 0l5.5-3.18c.46-.27.75-.76.75-1.3V8.9c0-.54-.29-1.03-.75-1.3zM7 14.96v-4.62l4 2.32v4.61l-4-2.31zm5-4.03L8 8.61l4-2.31 4 2.31-4 2.32zm1 6.34v-4.61l4-2.32v4.62l-4 2.31zM7 2H3.5C2.67 2 2 2.67 2 3.5V7h2V4h3V2zm10 0h3.5c.83 0 1.5.67 1.5 1.5V7h-2V4h-3V2zM7 22H3.5c-.83 0-1.5-.67-1.5-1.5V17h2v3h3v2zm10 0h3.5c.83 0 1.5-.67 1.5-1.5V17h-2v3h-3v2z"},child:[]}]})(t)}function Qs(t){return kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"},child:[]},{tag:"path",attr:{d:"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"},child:[]}]})(t)}function tr(t){return kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"},child:[]},{tag:"path",attr:{d:"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"},child:[]}]})(t)}function er(t){return kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0V0z"},child:[]},{tag:"path",attr:{d:"m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"},child:[]}]})(t)}function nr(t){return kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M24 24H0V0h24v24z",opacity:".87"},child:[]},{tag:"path",attr:{d:"M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"},child:[]}]})(t)}function ir(){const{stepList:t,setStepPosition:n,stepCount:e,currentStepName:i,modelProperties:s}=B.useContext(nt);B.useState("stepNaviBtn");const[a,r]=B.useState();t&&[...Array(t.length)];const[o,c]=B.useState(!1),f=()=>{c(!o)};return B.useEffect(()=>{const l=()=>{window.innerWidth<890&&c(!1)};return window.addEventListener("resize",l),l(),()=>window.removeEventListener("resize",l)},[]),D(H,{children:[z("button",{className:"hamburgerStepNavi",onClick:f,children:o?z(Qs,{}):z(tr,{})}),z("div",{className:o?"stepNaviMobile":"stepNavi",children:z("ul",{children:t?t.map((l,d)=>z("li",{children:s&&l===s.titleName?z("button",{id:`${l}`,style:{backgroundColor:"#000000",color:"#ffffff"},onClick:()=>{n(d)},className:o?"stepNaviBtnMobile":"stepNaviBtn",children:l}):z("button",{id:`${l}`,style:{backgroundColor:a},onClick:()=>{n(d)},className:o?"stepNaviBtnMobile":"stepNaviBtn",children:l})},d)):null})})]})}const sr=et.memo(ir);function rr({cameraControlsRef:t}){let{visibleObj:n,modelProperties:e,selectedPartsModel:i,selectedParts:s,currentObject:a,setCamera:r,partBtnState:o,currentStepObject:c}=B.useContext(nt);const f=Un(),l=W(d=>d.cameraPositionTag);B.useEffect(()=>{n?(f.refresh(n).fit().clip(),zt()):(f.refresh(c).fit().clip(),zt())},[c,l])}function He(t){return kt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"circle",attr:{cx:"12",cy:"12",r:"10"},child:[]},{tag:"line",attr:{x1:"12",x2:"12",y1:"8",y2:"12"},child:[]},{tag:"line",attr:{x1:"12",x2:"12.01",y1:"16",y2:"16"},child:[]}]})(t)}let We=1,Wn=new Array;new Array;let Le=new Array,jt;Rn.get("https://sheets.googleapis.com/v4/spreadsheets/11ayVTVvDEbOezJJSL6N2_ct-rm7NgKWlpBPqqtvVh5U/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(t=>{let n=t.data.values,e=new Array;for(const i of n)We>2&&i[1]!=""&&(Wn.push(e),e=new Array),e.push(i),++We});function Kn(){let{stepCount:t}=B.useContext(nt);const n=W(s=>s.isVisible);B.useState();const e=W(s=>s.isNotVisibleToggle),i=W(s=>s.isVisibleToggle);return B.useEffect(()=>{jt=new Array;for(const s of Wn[t+1])s[10]!=""&&s[10]!=null&&(Le=new Array,Le.push(s[10]),jt.push(Le)),++We},[t]),B.useEffect(()=>{jt.length===0?e():i()},[t]),z(H,{children:jt?D("div",{children:[D("div",{id:"RemarksTitle",style:{alignContent:"baseline",visibility:`${n}`},children:[D("h3",{children:[" ",z(He,{})," Remarks"]})," ",z("br",{})]}),z("ul",{children:jt.map((s,a)=>D("li",{children:[" ",s]},a))})]}):null})}/**
  * react-collapsed v4.1.2
  *
  * Copyright (c) 2019-2023, Rogin Farrer
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */var or=class extends Error{constructor(t){super(`react-collapsed: ${t}`)}},ye=(...t)=>(t[0],`${t[1]}`,void 0);function Xn(t){const n=B.useRef(t);return B.useEffect(()=>{n.current=t}),B.useCallback((...e)=>{var i;return(i=n.current)==null?void 0:i.call(n,...e)},[])}function cr(t,n,e){const[i,s]=B.useState(n),a=B.useRef(typeof t<"u"),r=a.current?t:i,o=Xn(e),c=B.useCallback(f=>{const d=typeof f=="function"?f(r):f;a.current||s(d),o==null||o(d)},[o,r]);return B.useEffect(()=>{ye(!(a.current&&t==null),"`isExpanded` state is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."),ye(!(!a.current&&t!=null),"`isExpanded` state is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.")},[t]),[r,c]}var ar="(prefers-reduced-motion: reduce)";function lr(){const[t,n]=B.useState(!1);return B.useEffect(()=>{if(typeof window>"u"||typeof window.matchMedia!="function")return;const e=window.matchMedia(ar);n(e.matches);const i=s=>{n(s.matches)};if(e.addEventListener)return e.addEventListener("change",i),()=>{e.removeEventListener("change",i)};if(e.addListener)return e.addListener(i),()=>{e.removeListener(i)}},[]),t}var ur=vi["useId".toString()]||(()=>{});function fr(){return ur()??""}var dr=typeof window<"u"?B.useLayoutEffect:B.useEffect,Ue=!1,pr=0,Tn=()=>++pr;function mr(t){const n=t||(Ue?Tn():null),[e,i]=B.useState(n);return dr(()=>{e===null&&i(Tn())},[]),B.useEffect(()=>{Ue===!1&&(Ue=!0)},[]),e!=null?String(e):void 0}function hr(t){const n=fr(),e=mr(t);return typeof t=="string"?t:typeof n=="string"?n:e}function yr(t,n){const e=performance.now(),i={};function s(){i.id=requestAnimationFrame(a=>{a-e>n?t():s()})}return s(),i}function Cn(t){t.id&&cancelAnimationFrame(t.id)}function _n(t){return t!=null&&t.current?t.current.scrollHeight:(ye(!0,"Was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\nconst collapseProps = getCollapseProps({refKey: 'innerRef'})"),0)}function gr(t){if(!t||typeof t=="string")return 0;const n=t/36;return Math.round((4+15*n**.25+n/5)*10)}function vr(t,n){if(t!=null)if(typeof t=="function")t(n);else try{t.current=n}catch{throw new or(`Cannot assign value "${n}" to ref "${t}"`)}}function Bn(...t){return t.every(n=>n==null)?null:n=>{t.forEach(e=>{vr(e,n)})}}function xr(t){let n=e=>{};n=e=>{if(!(e!=null&&e.current))return;const{paddingTop:i,paddingBottom:s}=window.getComputedStyle(e.current);ye(!(i&&i!=="0px"||s&&s!=="0px"),`Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element. Example:

Before:   <div {...getCollapseProps({style: {padding: 10}})}>{children}</div>

After:   <div {...getCollapseProps()}>
             <div style={{padding: 10}}>
                 {children}
             </div>
          </div>`)},B.useEffect(()=>{n(t)},[t])}var br=typeof window>"u"?B.useEffect:B.useLayoutEffect;function wr({duration:t,easing:n="cubic-bezier(0.4, 0, 0.2, 1)",onTransitionStateChange:e=()=>{},isExpanded:i,defaultExpanded:s=!1,hasDisabledAnimation:a,id:r,...o}={}){const c=Xn(e),f=hr(r?`${r}`:void 0),[l,d]=cr(i,s),u=B.useRef(l),[h,w]=B.useState(!1),_=lr(),A=a??_,y=B.useRef(),v=B.useRef(),g=B.useRef(null),[x,S]=B.useState(null);xr(g);const T=`${o.collapsedHeight||0}px`;function P(p){if(!g.current)return;const m=g.current;for(const b in p){const M=p[b];M?m.style[b]=M:m.style.removeProperty(b)}}return br(()=>{if(!g.current||l===u.current)return;u.current=l;function m(C){return A?0:t??gr(C)}const b=C=>`height ${m(C)}ms ${n}`,M=C=>{function E(){l?(P({height:"",overflow:"",transition:"",display:""}),c("expandEnd")):(P({transition:""}),c("collapseEnd")),w(!1)}v.current&&Cn(v.current),v.current=yr(E,C)};return w(!0),l?y.current=requestAnimationFrame(()=>{c("expandStart"),P({display:"block",overflow:"hidden",height:T}),y.current=requestAnimationFrame(()=>{c("expanding");const C=_n(g);M(m(C)),g.current&&(g.current.style.transition=b(C),g.current.style.height=`${C}px`)})}):y.current=requestAnimationFrame(()=>{c("collapseStart");const C=_n(g);M(m(C)),P({transition:b(C),height:`${C}px`}),y.current=requestAnimationFrame(()=>{c("collapsing"),P({height:T,overflow:"hidden"})})}),()=>{y.current&&cancelAnimationFrame(y.current),v.current&&Cn(v.current)}},[l,T,A,t,n,c]),{isExpanded:l,setExpanded:d,getToggleProps(p){const{disabled:m,onClick:b,refKey:M,...C}={refKey:"ref",onClick(){},disabled:!1,...p},E=x?x.tagName==="BUTTON":void 0,k=p==null?void 0:p[M||"ref"],O={id:`react-collapsed-toggle-${f}`,"aria-controls":`react-collapsed-panel-${f}`,"aria-expanded":l,onClick(st){m||(b==null||b(st),d(ct=>!ct))},[M||"ref"]:Bn(k,S)},R={type:"button",disabled:m?!0:void 0},q={"aria-disabled":m?!0:void 0,role:"button",tabIndex:m?-1:0};return E===!1?{...O,...q,...C}:E===!0?{...O,...R,...C}:{...O,...R,...q,...C}},getCollapseProps(p){const{style:m,refKey:b}={refKey:"ref",style:{},...p},M=p==null?void 0:p[b||"ref"];return{id:`react-collapsed-panel-${f}`,"aria-hidden":!l,"aria-labelledby":`react-collapsed-toggle-${f}`,role:"region",...p,[b||"ref"]:Bn(g,M),style:{boxSizing:"border-box",...!h&&!l?{display:T==="0px"?"none":"block",height:T,overflow:"hidden"}:{},...m}}}}}function Ar(){const t=B.useRef(),[n,e]=B.useState(!1),{getCollapseProps:i,getToggleProps:s}=wr({isExpanded:n}),a=W(r=>r.isVisible);return D(H,{children:[z("button",{type:"button",...s({onClick:()=>{e(r=>!r)}}),className:"remarksCollapsible",style:{position:"absolute",top:"20px",left:"20px",visibility:`${a}`,justifyContent:"space-between",alignItems:"center"},children:n?D(H,{children:[z(He,{size:22})," ",z(er,{})]}):D(H,{children:[z(He,{size:22})," ",z(nr,{})]})}),z("div",{ref:t,className:"remarksContent",...i(),children:z(Kn,{})})]})}let Mn=1,Sr=new Array;new Array;Rn.get("https://sheets.googleapis.com/v4/spreadsheets/11ayVTVvDEbOezJJSL6N2_ct-rm7NgKWlpBPqqtvVh5U/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(t=>{let n=t.data.values,e=new Array;for(const i of n)Mn>2&&i[1]!=""&&(Sr.push(e),e=new Array),e.push(i),++Mn});function Pr(){let{visibleObj:t,selectedParts:n,stepSVG:e}=B.useContext(nt);const i=W(l=>l.cameraPositionTag),s=W(l=>l.freeControls),a=W(l=>l.wiringStep),r=Un(),[o]=B.useState(()=>new L),[c]=B.useState(()=>new L),f=new L(4,1,8);return xi((l,d)=>{i==="initial"&&a===!1&&(o.lerp(f,.1),c.lerp([0,0,0],.1),l.camera.position.copy(o),l.camera.lookAt(c),s(),r.refresh(t).fit(),zt()),i==="initial"&&a===!0&&(console.log(e),e.reset(),s(),zt())}),z(H,{})}function Er(){const t=Bt("./Tchibo_IN.glb"),n=Bt("./Tchibo_OUT.glb"),e=B.useMemo(()=>t.scene.clone(),[t]),i=B.useMemo(()=>t.scene.clone(),[t]),s=B.useMemo(()=>n.scene.clone(),[n]);B.useState(!1),B.useRef(),B.useRef(),Bt.clear("./Tchibo_IN.glb"),Bt.clear("./Tchibo_OUT.glb");const a=W(r=>r.resetCamera);return z(H,{children:D(B.Fragment,{children:[z(sr,{}),D("section",{id:"currentStepArea",children:[z("h2",{id:"stepTitleArea",children:z(qs,{})}),z("nav",{className:"currentStepBar",children:D("div",{id:"stepControl",children:[z(_i,{}),"                        "]})}),D("div",{className:"infoColumn",children:[z("div",{className:"stepPartsArea",children:z($s,{})}),z("div",{className:"stepRemarksArea",children:z(Kn,{})})]}),D("article",{className:"viewArea",id:"viewArea",children:[z(B.Suspense,{fallback:null,children:D(bi,{linear:!0,flat:!0,frameloop:"demand",camera:{fov:45,near:1,far:10,position:[4,1,8]},children:[z(Tr,{}),z("color",{args:["#f5f5f5"],attach:"background"}),z(wi,{clip:!0,observe:!0,damping:2,margin:.85,children:D(B.Suspense,{fallback:null,children:[z(Is,{modelIn:t,modelOut:n,modelInCopy:e,modelInCopy2:i,modelOutCopy:s}),z(rr,{})]})}),z(Pr,{})]})}),z(Ci,{}),D("button",{className:"btn",style:{position:"absolute",bottom:"20px",left:"20px"},onClick:a,children:[z(Js,{})," Reset Camera"]}),z(Bi,{}),z(Ar,{})]})]})]})})}Bt.preload("./Tchibo_IN.glb");Bt.preload("./Tchibo_OUT.glb");function Tr(){const t=B.useRef();return z(H,{children:z(Ai,{ref:t,makeDefault:!0,enableDamping:!1,enableRotate:!0,minAzimuthAngle:1/0,maxAzimuthAngle:1/0,minPolarAngle:0,maxPolarAngle:1/0})})}export{Er as default};
//# sourceMappingURL=App-0e0fae4f.js.map
